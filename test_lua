-- @region = Script Info

-- Owner: TiagoSuper3/Hypertt
-- Script Name: Valency
-- Version = idk

-- @end_region = Script Info


-- @region = FFI

local ffi = require "ffi"
local urlmon = ffi.load 'UrlMon'
local wininet = ffi.load 'WinInet'

ffi.cdef[[
    struct pose_parameters_t {
        char pad[8];
        float m_flStart;
        float m_flEnd;
        float m_flState;
    };

        enum { CF_TEXT = 1 };
        int      OpenClipboard(void*);
        void*    GetClipboardData(unsigned);
        int      CloseClipboard();
        void*    GlobalLock(void*);
        int      GlobalUnlock(void*);
        size_t   GlobalSize(void*);
            typedef void(__thiscall* asp_t)(void*, const char*, const char*, int);
            typedef bool(__thiscall* rsp_t)(void*, const char*, const char*);
            typedef int(__thiscall* gcpbs_t)(void*);
            typedef int(__thiscall* gcpbt_t)(void*, int,  char*, int);
            typedef char(__thiscall* gcd_t)(void*, char*, int);
            typedef bool(__thiscall* mv_t)(void*, const char*, const char*, const char*);
            typedef int(__thiscall* get_clipboard_text_count)(void*);
            typedef void(__thiscall* set_clipboard_text)(void*, const char*, int);
            typedef void(__thiscall* get_clipboard_text)(void*, int, const char*, int);


        bool CreateDirectoryA(const char* lpPathName, void* lpSecurityAttributes);
        void* __stdcall URLDownloadToFileA(void* LPUNKNOWN, const char* LPCSTR, const char* LPCSTR2, int a, int LPBINDSTATUSCALLBACK);        
        bool DeleteUrlCacheEntryA(const char* lpszUrlName);
        
        typedef struct {
            uint8_t r;
            uint8_t g;
            uint8_t b;
            uint8_t a;
        }color_struct_t;
  
        typedef void (__cdecl* console_color_print)(void*,const color_struct_t&, const char*, ...);
        typedef uintptr_t (__thiscall* GetClientEntity_4242425_t)(void*, int);
        typedef void*(__thiscall* get_list_of_client_entities)(void*, int);
        typedef int(__fastcall* clantag_t)(const char*, const char*);

        typedef struct {
                unsigned short wYear;
                unsigned short wMonth;
                unsigned short wDayOfWeek;
                unsigned short wDay;
                unsigned short wHour;
                unsigned short wMinute;
                unsigned short wSecond;
                unsigned short wMilliseconds;
        } SYSTEMTIME, *LPSYSTEMTIME;
            
        void GetSystemTime(LPSYSTEMTIME lpSystemTime);
        void GetLocalTime(LPSYSTEMTIME lpSystemTime);
]]

variabletable = {
    entry = function(instance, index, type)
        return ffi.cast(type, (ffi.cast("void***", instance)[0])[index])
    end,
    
    thunk = function(self, index, typestring)
        local t = ffi.typeof(typestring)
        return function(instance, ...)
            assert(instance ~= nil)
            if instance then
                return self.entry(instance, index, t)(instance, ...)
            end
        end
    end,
    
    bind = function(self, module, interface, index, typestring)
        local instance = Utils.CreateInterface(module, interface)
        local fnptr = self.entry(instance, index, ffi.typeof(typestring))
        return function(...)
            return fnptr(instance, ...)
        end
    end
}

-- @end_region = FFI


------ notas ------
--   ATTACK            = bit_lshift(1, 0)  Weapon fire
--   JUMP                = bit_lshift(1, 1)
--   DUCK                = bit_lshift(1, 2)
--   FORWARD            = bit_lshift(1, 3)  Forward move
--   BACK                = bit_lshift(1, 4)  Backwards move
--   USE                = bit_lshift(1, 5)  Use (Defuse bomb, open door, etc...)
--   CANCEL            = bit_lshift(1, 6)
--   LEFT                = bit_lshift(1, 7)  Left move
--   RIGHT            = bit_lshift(1, 8)  Right move
--   MOVELEFT            = bit_lshift(1, 9)  Alias? (not sure)
--   MOVERIGHT        = bit_lshift(1, 10)  Alias? (not sure)
--   ATTACK2            = bit_lshift(1, 11)  Secondary fire (Revolver, Glock change fire mode, Famas change fire mode) (not sure)
--   RUN                = bit_lshift(1, 12)
--   RELOAD            = bit_lshift(1, 13)  Reload weapon
--   ALT1                = bit_lshift(1, 14)
--   ALT2                = bit_lshift(1, 15)
--   SCORE            = bit_lshift(1, 16)
--   SPEED            = bit_lshift(1, 17)
--   WALK                = bit_lshift(1, 18)  Shift
--   ZOOM                = bit_lshift(1, 19)  Zoom weapon (not sure)
--   WEAPON1            = bit_lshift(1, 20)
--   WEAPON2            = bit_lshift(1, 21)
--   BULLRUSH            = bit_lshift(1, 22)
--   ONGROUND            = bit_lshift(1, 0)
--   DUCKING            = bit_lshift(1, 1)
--   WATERJUMP        = bit_lshift(1, 3)
--   ONTRAIN            = bit_lshift(1, 4)
--   INRAIN            = bit_lshift(1, 5)
--   FROZEN            = bit_lshift(1, 6)
--   ATCONTROLS       = bit_lshift(1, 7)
--   CLIENT            = bit_lshift(1, 8)
--   FAKECLIENT       = bit_lshift(1, 9)
--   INWATER            = bit_lshift(1, 10)
-------------------

local logs = {
    reason = {
        "resolver",
        "spread",
        "occlusion",
        "prediction error"
    },    
    hitgroups = {
        "generic",
        "head",
        "chest",
        "stomach",
        "left arm",
        "right arm", 
        "left leg",
        "right leg", 
        "gear"
    }
}

function Download(from, to)
    wininet.DeleteUrlCacheEntryA(from)
    urlmon.URLDownloadToFileA(nil, from, to, 0, 0)
end

function CreateDir(path)
    ffi.C.CreateDirectoryA(path, NULL)
end

-- @region = FileSystem

full_filesystem = Utils.CreateInterface("filesystem_stdio.dll", "VFileSystem017")
full_filesystem_class = ffi.cast(ffi.typeof("void***"), full_filesystem)
full_filesystem_vftbl = full_filesystem_class[0]
func_add_search_path = ffi.cast("void (__thiscall*)(void*, const char*, const char*, int)", full_filesystem_vftbl[11])
func_remove_search_path = ffi.cast("bool (__thiscall*)(void*, const char*, const char*)", full_filesystem_vftbl[12])
func_is_directory = ffi.cast("bool (__thiscall*)(void*, const char*, const char*)", full_filesystem_vftbl[23])
func_find_first = ffi.cast("const char* (__thiscall*)(void*, const char*, int*)", full_filesystem_vftbl[32])
func_find_next = ffi.cast("const char* (__thiscall*)(void*, int)", full_filesystem_vftbl[33])
func_find_is_directory = ffi.cast("bool (__thiscall*)(void*, int)", full_filesystem_vftbl[34])
func_find_close = ffi.cast("void (__thiscall*)(void*, int)", full_filesystem_vftbl[35])

local FileSystem = {}
local index = 0
local font_files = {}
local sound_files = {}

function FileSystem.find_first(path)
    local handle = ffi.new("int[1]")
    local file = func_find_first(full_filesystem_class, path, handle)
    if file == ffi.NULL then return nil end

    return handle, ffi.string(file)
end

function FileSystem.find_next(handle)
    local file = func_find_next(full_filesystem_class, handle)
    if file == ffi.NULL then return nil end

    return ffi.string(file)
end

function FileSystem.is_directory(path, path_id)
    return func_is_directory(full_filesystem_class, path, path_id)
end

function FileSystem.find_close(handle)
    func_find_close(full_filesystem_class, handle)
end

function FileSystem.add_search_path(path, path_id, type)
    func_add_search_path(full_filesystem_class, path, path_id, type)
end

function FileSystem.remove_search_path(path, path_id)
    func_remove_search_path(full_filesystem_class, path, path_id)
end

function FileSystem.get_neverlose_path()
    return EngineClient:GetGameDirectory():sub(1, -5) .. "nl\\"
end

function FileSystem.get_csgo_path()
    return EngineClient:GetGameDirectory():sub(1, -5)
end

-- @end_region = FileSystem


-- @region = Font / Sound Download

local lua_path = FileSystem.get_neverlose_path() .. "valency.lua\\"
local lua_sound_path = FileSystem.get_csgo_path() .. "csgo\\sound\\valency.lua\\"

folderscan = function()
    local my_path = FileSystem.get_neverlose_path() .. "valency.lua\\"

    FileSystem.add_search_path(lua_path, "GAME", 0)
    if FileSystem.is_directory(lua_path, "GAME") == false then
        CreateDir("nl\\valency.lua\\")
        logs[#logs+1] = {
            {
                {
                    text = "[VALENCY] ",
                    color = Color.RGBA(255, 0, 0, 255)
                },
                {
                    text = "Downloaded ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Needed ",
                    color = Color.RGBA(255, 0, 0, 255)
                },
                {
                    text = "Fonts ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Automatically.",
                    color = Color.RGBA(255, 0, 0, 255)
                },
            }, GlobalVars.realtime + 2, 0,
        }
        Download('https://github.com/TiagoSuper3/neverlosenokiascript/raw/main/Smallest-Pixel.ttf', 'nl\\valency.lua\\Smallest-Pixel.ttf')
        Download('https://github.com/TiagoSuper3/neverlosenokiascript/raw/main/Acta%20Symbols%20W95%20Arrows.ttf', 'nl\\valency.lua\\Acta-W95-Arrows.ttf')
        FileSystem.remove_search_path(lua_path, "GAME")
        return
    end

    local handle, file = FileSystem.find_first(lua_path .. "*.*")
    while file do
        if string.find(file, ".ttf") then
            font_files[index] = file index = index + 1
        end

        file = FileSystem.find_next(handle[0])
    end
    
    FileSystem.find_close(handle[0])
    if #font_files == 0 then
        logs[#logs+1] = {
            {
                {
                    text = "[VALENCY] ",
                    color = Color.RGBA(255, 0, 0, 255)
                },
                {
                    text = "Found ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Missing ",
                    color = Color.RGBA(255, 0, 0, 255)
                },
                {
                    text = "or ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Corrupted ",
                    color = Color.RGBA(255, 0, 0, 255)
                },  
                {
                    text = "Font(s) ",
                    color = Color.RGBA(255, 0, 0, 255)
                },
                {
                    text = "From The Respective ",
                    color = Color.RGBA(255, 255, 255, 255)
                },           
                {
                    text = "Folder. ",
                    color = Color.RGBA(255, 0, 0, 255)
                },    
                {
                    text = "Downloaded ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Missing ",
                    color = Color.RGBA(255, 0, 0, 255)
                },   
                {
                    text = "Font(s) ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Automatically.",
                    color = Color.RGBA(255, 0, 0, 255)
                },   
            }, GlobalVars.realtime + 2, 0,
        }
        Download('https://github.com/TiagoSuper3/neverlosenokiascript/raw/main/Smallest-Pixel.ttf', 'nl\\valency.lua\\Smallest-Pixel.ttf')
        Download('https://github.com/TiagoSuper3/neverlosenokiascript/raw/main/Acta%20Symbols%20W95%20Arrows.ttf', 'nl\\valency.lua\\Acta-W95-Arrows.ttf')
    end

    FileSystem.remove_search_path(lua_path, "GAME")

    FileSystem.add_search_path(lua_sound_path, "GAME", 0)
    if FileSystem.is_directory(lua_sound_path, "GAME") == false then
        logs[#logs+1] = {
            {
                {
                    text = "[VALENCY] ",
                    color = Color.RGBA(255, 0, 0, 255)
                },
                {
                    text = "Downloaded ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Needed ",
                    color = Color.RGBA(255, 0, 0, 255)
                },
                {
                    text = "Sounds ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Automatically.",
                    color = Color.RGBA(255, 0, 0, 255)
                },
            }, GlobalVars.realtime + 2, 0,
        }
        CreateDir("csgo\\sound\\valency.lua\\")
        Download('https://github.com/TiagoSuper3/neverlosenokiascript/raw/main/glass.wav', 'csgo\\sound\\valency.lua\\glass.wav')
        FileSystem.remove_search_path(lua_sound_path, "GAME")
        return
    end

    local handle, file = FileSystem.find_first(lua_sound_path .. "*.*")
    while file do
        if string.find(file, ".wav") then
            sound_files[index] = file index = index + 1
        end

        file = FileSystem.find_next(handle[0])
    end

    
    FileSystem.find_close(handle[0])
    if #sound_files == 0 then
        logs[#logs+1] = {
            {
                {
                    text = "[VALENCY] ",
                    color = Color.RGBA(255, 0, 0, 255)
                },
                {
                    text = "Found ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Missing ",
                    color = Color.RGBA(255, 0, 0, 255)
                },
                {
                    text = "or ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Corrupted ",
                    color = Color.RGBA(255, 0, 0, 255)
                },  
                {
                    text = "Sounds ",
                    color = Color.RGBA(255, 0, 0, 255)
                },  
                {
                    text = "From The Respective ",
                    color = Color.RGBA(255, 255, 255, 255)
                },           
                {
                    text = "Folder. ",
                    color = Color.RGBA(255, 0, 0, 255)
                },    
                {
                    text = "Downloaded ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Missing ",
                    color = Color.RGBA(255, 0, 0, 255)
                },   
                {
                    text = "Sound(s) ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Automatically.",
                    color = Color.RGBA(255, 0, 0, 255)
                },   
            }, GlobalVars.realtime + 2, 0,
        }
        Download('https://github.com/TiagoSuper3/neverlosenokiascript/raw/main/glass.wav', 'csgo\\sound\\valency.lua\\glass.wav')
    end

    FileSystem.remove_search_path(lua_sound_path, "GAME")
end
folderscan()

-- @end_region = Font / Sound Download


-- @region = Font Load

local font = {
    tahoma14bd = Render.InitFont("Tahoma", 14, {'b', 'd'}),
    tahoma20b = Render.InitFont("Tahoma", 20, {'b'}),
    verdana11r = Render.InitFont("Verdana", 11,{'r'}),
    verdana12 = Render.InitFont("Verdana", 12),
    verdana13r = Render.InitFont("Verdana", 13, {'r'}),
    verdana25 = Render.InitFont("Verdana", 25),
    verdana40r = Render.InitFont("Verdana", 40, {'r'}),
    pixel10 = Render.InitFont("nl\\valency.lua\\Smallest-Pixel.ttf", 10),
    arrows55 = Render.InitFont("nl\\valency.lua\\Acta-W95-Arrows.ttf", 55),
    calibribold10 = Render.InitFont("Calibri Bold", 10),
    calibri26 = Render.InitFont("Calibri", 26),
    calibri38 = Render.InitFont("Calibri", 38),
    calibri48 = Render.InitFont("Calibri", 48),
}

local player_name = {
    steam = Panorama.Open().MyPersonaAPI.GetName(),
    cheat = Cheat.GetCheatUserName(),
}

local engine_client = {
    screen_size = EngineClient.GetScreenSize(),
    screen_center = EngineClient.GetScreenSize() / 2
}

-- @end_region = Font Load


-- @region = Tab Alignment 

    local Tab = {
        ["Global"] = {},
        ["Anti Aim"] = {},
        ["Anti Bruteforce"] = {},
        ["Visuals"] = {},
        ["Misc"] = {},
    }



    local info_page_align = Menu.Text("Info", "", "")
    info_page_align:SetVisible(false)



    Tab["Global"].global_bool = {
        var = Menu.Switch("Global", "Global", "Enable Global", false, "ON/OFF Switch"),
        color = false,
    }
    local global_bool = Tab["Global"].global_bool.var

    local global_page_align = Menu.Text("Global", "", "")
    global_page_align:SetVisible(false)



    local antiaim_page_align = Menu.Text("Anti Aim", "", "")
    antiaim_page_align:SetVisible(false)



    Tab["Anti Bruteforce"].antibruteforce_bool = {
        var = Menu.Switch("Anti Bruteforce", "Anti Bruteforce", "Enable", false, "ON/OFF Switch"),
        color = false,
    }
    local antibruteforce_bool = Tab["Anti Bruteforce"].antibruteforce_bool.var

    local antibruteforce_page_align = Menu.Text("Anti Bruteforce", "", "")
    antibruteforce_page_align:SetVisible(false)



    Tab["Visuals"].visuals_bool = {
        var = Menu.Switch("Visuals", "Visuals", "Enable Visuals", false, "ON/OFF Switch"),
        color = false,
    }
    local visuals_bool = Tab["Visuals"].visuals_bool.var

    local visuals_page_align = Menu.Text("Visuals", "", "")
    visuals_page_align:SetVisible(false)



    Tab["Misc"].misc_bool = {
        var = Menu.Switch("Misc", "Misc", "Enable Misc", false, "ON/OFF Switch"),
        color = false,
    }
    local misc_bool = Tab["Misc"].misc_bool.var

    local misc_page_align = Menu.Text("Misc", "", "")
    misc_page_align:SetVisible(false)



    local config_page_align = Menu.Text("Config", "", "")
    config_page_align:SetVisible(false)

-- @end_region = Tab Alignment 


-- @region = Config System

local json = { _version = "0.1.2" }
-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local JSON = Panorama.LoadString([[
    return {
        stringify: JSON.stringify,
        parse: JSON.parse
    };
]])()

local encode

local escape_char_map = {
  [ "\\" ] = "\\",
  [ "\"" ] = "\"",
  [ "\b" ] = "b",
  [ "\f" ] = "f",
  [ "\n" ] = "n",
  [ "\r" ] = "r",
  [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte()))
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end


type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.encode(val)
  return ( encode(val) )
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(1, 4),  16 )
  local n2 = tonumber( s:sub(7, 10), 16 )
   -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


function parse_string(str, i)
  local res = ""
  local j = i + 1
  local k = j

  while j <= #str do
    local x = str:byte(j)

    if x < 32 then
      decode_error(str, j, "control character in string")

    elseif x == 92 then -- `\`: Escape
      res = res .. str:sub(k, j - 1)
      j = j + 1
      local c = str:sub(j, j)
      if c == "u" then
        local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                 or str:match("^%x%x%x%x", j + 1)
                 or decode_error(str, j - 1, "invalid unicode escape in string")
        res = res .. parse_unicode_escape(hex)
        j = j + #hex
      else
        if not escape_chars[c] then
          decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
        end
        res = res .. escape_char_map_inv[c]
      end
      k = j + 1

    elseif x == 34 then -- `"`: End of string
      res = res .. str:sub(k, j - 1)
      return res, j + 1
    end

    j = j + 1
  end

  decode_error(str, i, "expected closing quote for string")
end


function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
return res
end

local bit = require "bit"
local M = {}

local shl, shr, band = bit.lshift, bit.rshift, bit.band
local char, byte, gsub, sub, format, concat, tostring, error, pairs =
    string.char,
    string.byte,
    string.gsub,
    string.sub,
    string.format,
    table.concat,
    tostring,
    error,
    pairs

local extract = function(v, from, width)
    return band(shr(v, from), shl(1, width) - 1)
end

local function makeencoder(alphabet)
    local encoder, decoder = {}, {}
    for i = 1, 65 do
        local chr = byte(sub(alphabet, i, i)) or 32 -- or " "
        if decoder[chr] ~= nil then
            error("invalid alphabet: duplicate character " .. tostring(chr), 3)
        end
        encoder[i - 1] = chr
        decoder[chr] = i - 1
    end
    return encoder, decoder
end

local encoders, decoders = {}, {}

encoders["base64"], decoders["base64"] = makeencoder("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=")
encoders["base64url"], decoders["base64url"] = makeencoder("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_")

local alphabet_mt = {
    __index = function(tbl, key)
        if type(key) == "string" and key:len() == 64 or key:len() == 65 then
            -- if key is a valid looking base64 alphabet, try to make an encoder/decoder pair from it
            encoders[key], decoders[key] = makeencoder(key)
            return tbl[key]
        end
    end
}

setmetatable(encoders, alphabet_mt)
setmetatable(decoders, alphabet_mt)

function M.encode(str, encoder)
    encoder = encoders[encoder or "base64"] or error("invalid alphabet specified", 2)

    str = tostring(str)

    local t, k, n = {}, 1, #str
    local lastn = n % 3
    local cache = {}

    for i = 1, n - lastn, 3 do
        local a, b, c = byte(str, i, i + 2)
        local v = a * 0x10000 + b * 0x100 + c
        local s = cache[v]

        if not s then
            s = char(encoder[extract(v, 18, 6)], encoder[extract(v, 12, 6)], encoder[extract(v, 6, 6)], encoder[extract(v, 0, 6)])
            cache[v] = s
        end

        t[k] = s
        k = k + 1
    end

    if lastn == 2 then
        local a, b = byte(str, n - 1, n)
        local v = a * 0x10000 + b * 0x100
        t[k] = char(encoder[extract(v, 18, 6)], encoder[extract(v, 12, 6)], encoder[extract(v, 6, 6)], encoder[64])
    elseif lastn == 1 then
        local v = byte(str, n) * 0x10000
        t[k] = char(encoder[extract(v, 18, 6)], encoder[extract(v, 12, 6)], encoder[64], encoder[64])
    end

    return concat(t)
end

function M.decode(b64, decoder)
    decoder = decoders[decoder or "base64"] or error("invalid alphabet specified", 2)

    local pattern = "[^%w%+%/%=]"
    if decoder then
        local s62, s63
        for charcode, b64code in pairs(decoder) do
            if b64code == 62 then
                s62 = charcode
            elseif b64code == 63 then
                s63 = charcode
            end
        end
        pattern = format("[^%%w%%%s%%%s%%=]", char(s62), char(s63))
    end

    b64 = gsub(tostring(b64), pattern, "")

    local cache = {}
    local t, k = {}, 1
    local n = #b64
    local padding = sub(b64, -2) == "==" and 2 or sub(b64, -1) == "=" and 1 or 0

    for i = 1, padding > 0 and n - 4 or n, 4 do
        local a, b, c, d = byte(b64, i, i + 3)

        local v0 = a * 0x1000000 + b * 0x10000 + c * 0x100 + d
        local s = cache[v0]
        if not s then
            local v = decoder[a] * 0x40000 + decoder[b] * 0x1000 + decoder[c] * 0x40 + decoder[d]
            s = char(extract(v, 16, 8), extract(v, 8, 8), extract(v, 0, 8))
            cache[v0] = s
        end

        t[k] = s
        k = k + 1
    end

    if padding == 1 then
        local a, b, c = byte(b64, n - 3, n - 1)
        local v = decoder[a] * 0x40000 + decoder[b] * 0x1000 + decoder[c] * 0x40
        t[k] = char(extract(v, 16, 8), extract(v, 8, 8))
    elseif padding == 2 then
        local a, b = byte(b64, n - 3, n - 2)
        local v = decoder[a] * 0x40000 + decoder[b] * 0x1000
        t[k] = char(extract(v, 16, 8))
    end
    return concat(t)
end

-- @end_region = Config System


-- @region = Usefull Math / Etc Functions 

color_print = function(color, text)
    local col = ffi.new("color_struct_t")
    interface_type = ffi.typeof("uintptr_t**")
    cvar_interface = ffi.cast(interface_type, Utils.CreateInterface("vstdlib.dll", "VEngineCvar007"))
    color_print_fn = ffi.cast("console_color_print", cvar_interface[0][25])

    col.r = color.r * 255
    col.g = color.g * 255
    col.b = color.b * 255
    col.a = color.a * 255

    color_print_fn(cvar_interface, col, text)
end

setclipboardtext = function(text)
    SetClipboardText = variabletable:bind("vgui2.dll", "VGUI_System010", 9, "void(__thiscall*)(void*, const char*, int)")
    SetClipboardText(text, text:len())
end

getclipboardtext = function()
    new_char_arr = ffi.typeof("char[?]")
    GetClipboardText = variabletable:bind("vgui2.dll", "VGUI_System010", 11, "int(__thiscall*)(void*, int, const char*, int)")
    GetClipboardTextCount = variabletable:bind("vgui2.dll", "VGUI_System010", 7, "int(__thiscall*)(void*)")
    local lenght = GetClipboardTextCount()
    if lenght > 0 then
        local char_arr = new_char_arr(lenght)
        GetClipboardText(0, char_arr, lenght)
        return ffi.string(char_arr, lenght-1)
    end
end

world2scren = function(xdelta, ydelta)
    if xdelta == 0 and ydelta == 0 then
        return 0
    end
    return math.deg(math.atan2(ydelta, xdelta))
end

normalizeyaw = function(flYaw)
	while flYaw > 180 do flYaw = flYaw - 360 end
	while flYaw < -180 do flYaw = flYaw + 360 end
	return flYaw
end

CalcAngle = function(local_pos, enemy_pos)
    local ydelta = local_pos.y - enemy_pos.y
    local xdelta = local_pos.x - enemy_pos.x
    local relativeyaw = math.atan( ydelta / xdelta )
    relativeyaw = normalizeyaw( relativeyaw * 180 / math.pi )
    if xdelta >= 0 then
        relativeyaw = normalizeyaw(relativeyaw + 180)
    end
    return relativeyaw
end

math_lerp = function(value_start, value_end, frametime)

    frametime = math_clamp(GlobalVars.frametime * (frametime * 175), 0, 1)

    if type(value_start) == "userdata" then
        r = math_lerp(value_start.r, value_end.r, frametime)
        g = math_lerp(value_start.g, value_end.g, frametime)
        b = math_lerp(value_start.b, value_end.b, frametime)
        a = math_lerp(value_start.a, value_end.a, frametime)
        return Color.new(r, g, b, a)
    end

    local value = value_end - value_start

    if value_end == 0 and value <= 0 and value >= 0 then
        value = 0
    elseif value_end == 1 and value <= 1 and value >= 1 then
        value = 1
    end

    value = value * frametime
    value = value + value_start

    return value
end

variaveis_animacao = {}
variaveis_animacao.default_anim_time = 0.095

new_animation = function(name, new_value, is_color)

    local animating = 0

    if variaveis_animacao[name] == nil then
        variaveis_animacao[name] = {
            pos = 0,
            color = Color.new(0, 0, 0, 0)
        }
    end

    if is_color then
        variaveis_animacao[name].color = math_lerp(variaveis_animacao[name].color, new_value, variaveis_animacao.default_anim_time)
        return variaveis_animacao[name].color
    else
        variaveis_animacao[name].pos = math_lerp(variaveis_animacao[name].pos, new_value, variaveis_animacao.default_anim_time)
        return variaveis_animacao[name].pos
    end
end

start_offset = 15
extend_offset = function(value)

    if type(value) ~= "number" then
        return visual_controller.non_lerp_offset
    end

    visual_controller.non_lerp_offset = visual_controller.non_lerp_offset + value
    return visual_controller.non_lerp_offset
end

isvalidlp = function()
    
    local lp = EngineClient.GetLocalPlayer()

    if not lp then 
        return nil 
    end

    local lp_entity = EntityList.GetClientEntity(lp)
    if not lp_entity then 
        return nil 
    end
  
    local lp_index = lp_entity:GetPlayer()
    if not lp_index then 
        return nil 
    end

    if not EngineClient.IsInGame() and not EngineClient.IsConnected() then 
        return nil 
    end

    if not lp_index:IsAlive() then 
        return nil 
    end

    return lp_index
end

math_deg_atan = function(xdelta, ydelta)
    if xdelta == 0 and ydelta == 0 then
        return 0
    end
    return math.deg(math.atan2(ydelta, xdelta))
end

normalize_vector = function(vec)
    return Vector.new(vec.x/#vec,vec.y/#vec,vec.z/#vec)
end

vec_closest_point_on_ray = function(target, rayStart, rayEnd) 
    local to = target-rayStart
    local direction = rayEnd - rayStart
    local lenght = #direction
    direction = normalize_vector(direction)

    local rangeAlong = direction:Dot(to)
    if rangeAlong < 0.0 then
        return rayStart
    end
    if rangeAlong > lenght then
        return rayEnd
    end

    return rayStart + (direction*Vector.new(rangeAlong, rangeAlong, rangeAlong))
end

vis = function(s, d)
    s:SetVisible(d)
end

math_round = function(value)
    return math.floor(value + 0.5)
end

math_clamp = function(value, min, max)
    return math.min(max, math.max(min, value))
end

math_normalize = function(ang)
    while (ang > 180.0) do
        ang = ang - 360.0
    end
    while (ang < -180.0) do
        ang = ang + 360.0
    end
    return ang
end

add_animation = function(condition, var, start_pos, end_pos, speed)
    if condition == nil then condition = true end
    
    if condition then
        var = var + speed
        if var > end_pos then var = end_pos end
        return var
    else
        var = var - speed
        if var < start_pos then var = start_pos end
        return var
    end
end

convertcolor_tostr = function(color)
    return {
        r = math_round(color.r * 255),
        g = math_round(color.g * 255),
        b = math_round(color.b * 255),
        a = math_round(color.a * 255),
    }
end

CanHit = function(enemy)
    local Localplayer = EntityList.GetLocalPlayer()
    local TraceInfo = Cheat.FireBullet(enemy, enemy:GetEyePosition(), Localplayer:GetEyePosition())

    if (TraceInfo.damage > 0 and ((TraceInfo.trace.hit_entity and TraceInfo.trace.hit_entity:GetPlayer() == Localplayer) or false)) then
        return true
    end

    return false
end

GetEnemies = function()
    local Enemies = {}

    for _, Player in pairs(EntityList.GetPlayers()) do
        if (not Player:IsTeamMate() and Player:IsAlive()) then
            table.insert(Enemies, Player:GetPlayer())
        end
    end

    return Enemies
end

GetDormantEnemy = function()

    local localplayer = isvalidlp()

    if localplayer == nil then 
        return 
    end
    
    for _, Enemy in pairs(GetEnemies()) do

        if Enemy == nil then
            return
        end

        if Enemy:IsDormant() and Enemy:GetNetworkState() == -1 then
            return Enemy
        end
    end
end

isColorEquals = function(clr1, clr2)
    return (clr1.r == clr2.r and clr1.g == clr2.g and clr1.b == clr2.b and clr1.a == clr2.a)
end

copyColor = function(src, dest)
    dest.r, dest.g, dest.b, dest.a = src.r, src.g, src.b, src.a
end

bind_get = function(name, bool)

    local binds = Cheat.GetBinds()
    for i = 1, #binds do
        local bind = binds[i]
        if bind:IsActive() then
            if bool == true and bind:GetName() == string.format("%s",name) then
                return true
            elseif bool == false and bind:GetName() == string.format("%s",name) then
                value = bind:GetValue() 
                return value
            end
        end
    end

    return false
end

is_valid = function(player) 
    if player == nil then 
        return false 
    else 
        if player:GetProp('m_iHealth') > 0 then
            return true
        else 
            return false
        end
    end
end

nearestenemy = function()

    if EngineClient.IsConnected() == nil or EngineClient.GetNetChannelInfo() == nil then 
        return 
    end

    local eyepos = EntityList.GetLocalPlayer():GetEyePosition()
    local viewangles = EngineClient.GetViewAngles()
    local bestenemy = nil
    local fov = 180

    for i=1, #EntityList.GetPlayers() do
        if(EntityList.GetPlayers()[i] ~= EntityList.GetLocalPlayer() and EntityList.GetPlayers()[i]:IsTeamMate() ~= true and is_valid(EntityList.GetPlayers()[i]) == true) then
            local cur = EntityList.GetPlayers()[i]:GetProp('m_vecOrigin')
            local cur_fov = math.abs(normalizeyaw(math_deg_atan(eyepos.x - cur.x, eyepos.y - cur.y) - viewangles.yaw + 180))
            if cur_fov < fov then
                fov = cur_fov
                bestenemy = EntityList.GetPlayers()[i]
            end
        end
    end
    return bestenemy == nil and EntityList.GetLocalPlayer() or bestenemy
    
end

GetFlag = function(player, shift)
    return bit.band(player:GetProp("m_fFlags"), bit.lshift(1, shift)) ~= 0
end

calculate_angle = function(src, dst)
    local vectorDelta = Vector.new(dst.x - src.x, dst.y - src.y, dst.z - src.z)
    local Qangles = QAngle.new(math.atan2(-vectorDelta.z, vectorDelta:Length2D()) * 180.0 / math.pi, (math.atan2(vectorDelta.y, vectorDelta.x) * 180.0 / math.pi), 0.0)
    return Qangles
end

auto_stop = function(player, cmd)

    local lp = player:GetPlayer()

    local vec_velocity = Vector.new(lp:GetProp("m_vecVelocity[0]"), lp:GetProp("m_vecVelocity[1]"), 0.0)
    local direction = Cheat.VectorToAngle(vec_velocity)

    direction.yaw = cmd.viewangles.yaw - direction.yaw

    local forward = Cheat.AngleToForward(direction)
    local negative = Vector2.new(forward.x * -200, forward.y * -200)
    

    cmd.forwardmove = negative.x
    cmd.sidemove = negative.y
end

-- @end_region = Usefull Math / Etc Functions 


-- @region = Lua Name On Bottom Screen

    local lualogo_menu = {}

    lualogo_menu.load_time = -1
    lualogo_menu.name = {"V", "A", "L","E", "N", "C", "Y", " ", "A", "N", "T", "I", "-", "A", "I", "M"}

    lualogo_menu.draw = function()

        if not Cheat.IsMenuVisible() then 
            lualogo_menu.load_time = -1
            return
        end

        if lualogo_menu.load_time == -1 then 
            lualogo_menu.load_time = GlobalVars.tickcount 
        end

        start = Vector2.new(engine_client.screen_center.x - 180, engine_client.screen_size.y - 60)

        diff = math.min(500, GlobalVars.tickcount - lualogo_menu.load_time)

        for i = 1, #lualogo_menu.name do
            this = i * 16
            if this < diff or diff > 300 then
                Render.Text(lualogo_menu.name[i], Vector2.new(start.x + 10 + i * 20, start.y + 25), Color.new(1.0, 1.0, 1.0), 20, font.tahoma20b, true)
            end
        end
    end

-- @end_region = Lua Name On Bottom Screen


-- @region = Boot Animation

    local boot_animation = {}

    local anim = 0
    local override_pitch = 0
    
    boot_anim = Menu.Switch("Info", "Animations", "Startup Animation", true)
    boot_animation.anim_loaded = false
    boot_animation.time_loaded = false
    boot_animation.x_adjust = engine_client.screen_size/2
    boot_animation.x_anim = -engine_client.screen_size.x/2
    boot_animation.welcome_string = "Welcome Back, "..player_name.cheat.."!"

    boot_animation.startup = function()

        if not boot_anim then
            boot_animation.anim_loaded = true
            return
        end

        local animation_frames = 2000 * GlobalVars.frametime

        if not boot_animation.time_loaded then
            boot_animation.time_total = GlobalVars.realtime + 2
            boot_animation.time_loaded = true
        end

        anim = add_animation(GlobalVars.realtime < boot_animation.time_total, anim, 0, 200, 5)
        override_pitch = add_animation(GlobalVars.realtime * 1.5 > boot_animation.time_total, override_pitch, 0, 90, 0.3)

        if GlobalVars.realtime < boot_animation.time_total then
            boot_animation.x_anim = boot_animation.x_anim + animation_frames
            if boot_animation.x_anim > 0 then boot_animation.x_anim = 0 end
        end


        logo_wide = Render.CalcTextSize("Valency Anti - Aim", 48, font.calibri48)
        welcomer_wide = Render.CalcTextSize(boot_animation.welcome_string, 38, font.calibri38)


        Render.Blur(Vector2.new(0, 0), engine_client.screen_size, Color.RGBA(0, 0, 0, anim))
        Render.Text("Valency Anti - Aim", boot_animation.x_adjust -  Vector2.new(logo_wide.x/2 - boot_animation.x_anim, 0), Color.RGBA(255, 255, 255, anim), 48, font.calibri48, true)
        Render.BoxFilled(boot_animation.x_adjust + Vector2.new(logo_wide.x/2 + boot_animation.x_anim, 50), (boot_animation.x_adjust - Vector2.new(logo_wide.x/2 - boot_animation.x_anim,-52)), Color.RGBA(255, 255, 255, anim)) 
        Render.Text(boot_animation.welcome_string, boot_animation.x_adjust - Vector2.new(welcomer_wide.x/2 - boot_animation.x_anim, -60), Color.RGBA(255, 255, 255, anim), 38, font.calibri38, true)
        AntiAim.OverridePitch(override_pitch)

        if anim == 0 then
            boot_animation.anim_loaded = true
        end
    end

-- @end_region = Boot Animation


-- @region = Cheat References 

local references = {
 aaenable = Menu.FindVar("Aimbot", "Anti Aim", "Main", "Enable Anti Aim"),
 left_limit = Menu.FindVar("Aimbot","Anti Aim","Fake Angle","Left Limit"),
 right_limit = Menu.FindVar("Aimbot","Anti Aim","Fake Angle","Right Limit"),
 options = Menu.FindVar("Aimbot","Anti Aim","Fake Angle","Fake Options"),
 lby_mode = Menu.FindVar("Aimbot","Anti Aim","Fake Angle","LBY Mode"),
 freestand = Menu.FindVar("Aimbot","Anti Aim","Fake Angle","Freestanding Desync"),
 onshot = Menu.FindVar("Aimbot","Anti Aim","Fake Angle","Desync On Shot"),
 yaw_base = Menu.FindVar("Aimbot","Anti Aim","Main","Yaw Base"),
 pitch = Menu.FindVar("Aimbot","Anti Aim","Main","Pitch"),
 yaw_add = Menu.FindVar("Aimbot","Anti Aim","Main","Yaw Add"),
 yaw_modifier = Menu.FindVar("Aimbot","Anti Aim","Main","Yaw Modifier"),
 modifier_degree = Menu.FindVar("Aimbot","Anti Aim","Main","Modifier Degree"),
 inverter = Menu.FindVar("Aimbot","Anti Aim","Fake Angle","Inverter"),
 isMD = Menu.FindVar("Aimbot","Ragebot","Accuracy","Minimum Damage"),
 isBA = Menu.FindVar("Aimbot","Ragebot","Misc","Body Aim"),
 isSP = Menu.FindVar("Aimbot","Ragebot","Misc","Safe Points"),
 isAP = Menu.FindVar("Miscellaneous","Main","Movement","Auto Peek"),
 isSW = Menu.FindVar("Aimbot","Anti Aim","Misc","Slow Walk"),
 isFD = Menu.FindVar("Aimbot","Anti Aim","Misc","Fake Duck"),
 doubletap = Menu.FindVar("Aimbot", "Ragebot", "Exploits", "Double Tap"),
 hideshot = Menu.FindVar("Aimbot", "Ragebot", "Exploits", "Hide Shots"),
 fl_limit = Menu.FindVar("Aimbot", "Anti Aim", "Fake Lag", "Limit"),
 fl_random = Menu.FindVar("Aimbot", "Anti Aim", "Fake Lag", "Randomization"),
}

-- @end_region = Cheat References 


-- @region = Anti Bruteforce

Tab["Anti Bruteforce"].add_phase = {
    var = Menu.Button("Anti Bruteforce", "Anti Bruteforce", "Add", ""),
    color = false,
}

Tab["Anti Bruteforce"].remove_phase = {
    var = Menu.Button("Anti Bruteforce", "Anti Bruteforce", "Remove", ""),
    color = false,
}

Tab["Anti Bruteforce"].phases_number = {
    var = Menu.SliderInt("Anti Bruteforce", "Anti Bruteforce","Phases number",2,2,12),
    color = false,
}
Tab["Anti Bruteforce"].phases_number.var:SetVisible(false)

local antibruteforce = {
 sliders_count = {},
 work = false,
 timework = 0.0,
 cache_work = {},
 cache = {}
}

for i = 0, 64 do
    table.insert(antibruteforce.cache,i,{count = 0})
end

antibruteforce.add_phase = function()
    if #antibruteforce.sliders_count > 11 then
        logs[#logs+1] = {
            {
                {
                    text = "[VALENCY] ",
                    color = Tab["Misc"].hitlogs_notColor.var:GetColor()
                },
                {
                    text = "You ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "can't ",
                    color = Tab["Misc"].hitlogs_notColor.var:GetColor()
                },
                {
                    text = "have ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "more ",
                    color = Tab["Misc"].hitlogs_notColor.var:GetColor()
                },
                {
                    text = "than ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "12 ",
                    color = Tab["Misc"].hitlogs_notColor.var:GetColor()
                },    
                {
                    text = "phases!",
                    color = Color.RGBA(255, 255, 255, 255)
                },           
            }, GlobalVars.realtime, 0,
        }
        return
    end

    Tab["Anti Bruteforce"]["phase_" .. (#antibruteforce.sliders_count + 1)] = {
        var = Menu.SliderInt("Anti Bruteforce", "Anti Bruteforce", "[Phase " .. (#antibruteforce.sliders_count + 1) .. "] Fake Limit", 0, -60, 60),
        color = false,
    }
    local new_phase_slider = Tab["Anti Bruteforce"]["phase_" .. (#antibruteforce.sliders_count + 1)].var
    table.insert(antibruteforce.sliders_count, new_phase_slider)
    Tab["Anti Bruteforce"].phases_number.var:Set(#antibruteforce.sliders_count)
end

antibruteforce.remove_phase = function()
    if #antibruteforce.sliders_count <= 2 then
        logs[#logs+1] = {
            {
                {
                    text = "[VALENCY] ",
                    color = Tab["Misc"].hitlogs_notColor.var:GetColor()
                },
                {
                    text = "You ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "can't ",
                    color = Tab["Misc"].hitlogs_notColor.var:GetColor()
                },
                {
                    text = "have ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "less ",
                    color = Tab["Misc"].hitlogs_notColor.var:GetColor()
                },
                {
                    text = "than ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "2 ",
                    color = Tab["Misc"].hitlogs_notColor.var:GetColor()
                },    
                {
                    text = "phases!",
                    color = Color.RGBA(255, 255, 255, 255)
                },           
            }, GlobalVars.realtime, 0,
        }
        return
    end


    Menu.DestroyItem(antibruteforce.sliders_count[#antibruteforce.sliders_count])
    table.remove(antibruteforce.sliders_count, #antibruteforce.sliders_count)
    Tab["Anti Bruteforce"].phases_number.var:Set(#antibruteforce.sliders_count)
end

for i = 1, Tab["Anti Bruteforce"].phases_number.var:Get() do
    antibruteforce.add_phase()
end

Tab["Anti Bruteforce"].add_phase.var:RegisterCallback(antibruteforce.add_phase)
Tab["Anti Bruteforce"].remove_phase.var:RegisterCallback(antibruteforce.remove_phase)

antibruteforce.restart_time = function()

    if not antibruteforce_bool:Get() then 
        return 
    end

    for i, var in ipairs(antibruteforce.cache_work) do
        if i > 1 then
            table.remove(antibruteforce.cache_work,i)
        end
        antibruteforce.work = true
        antibruteforce.timework = GlobalVars.realtime - var.time
        if antibruteforce.timework > 4 then
            antibruteforce.timework = 0
            antibruteforce.work = false
            table.remove(antibruteforce.cache_work,i)
        end
    end

end
 
antibruteforce.on_event = function(event)

    if not antibruteforce_bool:Get() then
        return
    end

    local localplayer = isvalidlp()

    if localplayer == nil then 
        return 
    end

    if event:GetName() ~= 'bullet_impact' or EngineClient.GetNetChannelInfo() == nil and not EngineClient.IsConnected() or is_valid(EntityList.GetPlayerForUserID(event:GetInt('userid'))) == false or EntityList.GetPlayerForUserID(event:GetInt('userid')):IsDormant() == true or EntityList.GetPlayerForUserID(event:GetInt('userid')):IsTeamMate() == true then 
        return 
    end
    
    local impact = Vector.new(event:GetInt('x'), event:GetInt('y'), event:GetInt('z'))
    local eyepos = EntityList.GetPlayerForUserID(event:GetInt('userid')):GetEyePosition()
    local headpos = localplayer:GetHitboxCenter(0)
    local head_vec = vec_closest_point_on_ray(headpos,eyepos,impact)
    local head_dist = headpos:DistTo(head_vec)
 
    if head_dist < 20 then

        antibruteforce.cache[EntityList.GetPlayerForUserID(event:GetInt('userid')):EntIndex()].count = antibruteforce.cache[EntityList.GetPlayerForUserID(event:GetInt('userid')):EntIndex()].count + 1
        if (#antibruteforce.sliders_count - 1) < antibruteforce.cache[EntityList.GetPlayerForUserID(event:GetInt('userid')):EntIndex()].count then
            antibruteforce.cache[EntityList.GetPlayerForUserID(event:GetInt('userid')):EntIndex()].count = 0
        end
        table.insert(antibruteforce.cache_work,1,{time = GlobalVars.realtime})
        logs[#logs+1] = {
            {
                {
                    text = "[VALENCY] ",
                    color = Color.RGBA(255, 255, 255, 255)
                },
                {
                    text = "Switched Side Due To Anti-Bruteforce.",
                    color = Color.RGBA(255, 255, 255, 255)
                }   
            }, GlobalVars.realtime, 0,
        }

    end
end

override_limit = function(angle, isoverride)
    if angle < 0  then
        if isoverride == true then AntiAim.OverrideInverter(true) end
        AntiAim.OverrideLimit(math.abs(angle))
    elseif angle == 0 or angle > 0  then
        if isoverride == true  then AntiAim.OverrideInverter(false)  end
        AntiAim.OverrideLimit(angle)
    end
end

-- @end_region = Anti Bruteforce


-- @region = Anti Aim Builder 

    local hook_aa = {}
    local aa = {}
    local state = {"Shared", "On Use", "Standing",  "Moving", "Air", "In Air Crouching", "Crouching", "SlowWalk", "Unconditional"}
    local currentid = 1
    local jitter = 1
    local roll_sway, sway_bool, roll = 0, false, 0

    Tab["Anti Aim"].antiaim_bool = {
        var = Menu.Switch("Anti Aim", "Anti-Aim Settings","Enable Conditional Anti-Aim", false),
        color = false
    }
    Tab["Anti Aim"].antiaim_manual = {
        var = Menu.Combo("Anti Aim", "Anti-Aim Settings", "Manual Yaw Base", {"Disable", "Forward", "Backward", "Right", "Left", "At Target", "Freestanding"}, 0),
        color = false
    }
    Tab["Anti Aim"].antiaim_conditions = {
        var = Menu.Combo("Anti Aim", "Anti-Aim Settings", "Current Condition", {state[i], "Shared", "On Use", "Standing", "Moving", "Air", "In Air Crouching", "Crouching", "Slowwalk"}, 0),
        color = false
    }

    aa[0] = 
    {
        antiaims = Tab["Anti Aim"].antiaim_bool.var,
        manual = Tab["Anti Aim"].antiaim_manual.var,
        antiaim = Tab["Anti Aim"].antiaim_conditions.var,
    }
    for i = 1, 9 do
        Tab["Anti Aim"]["custom_enable_"..i..""] = {var = Menu.Switch("Anti Aim", state[i], string.format("Override %s", state[i]), false), color = false}
        Tab["Anti Aim"]["custom_pitch_"..i..""] = {var = Menu.Combo("Anti Aim", state[i], "Pitch", {"Disabled", "Down", "Fake Down", "Fake Up"}, 1), color = false}
        Tab["Anti Aim"]["custom_yaw_base_"..i..""] = {var = Menu.Combo("Anti Aim", state[i], "Yaw Base", {"Forward", "Backward", "Right", "Left", "At Target", "Freestanding"}, 4), color = false}
        Tab["Anti Aim"]["custom_yaw_add_left_"..i..""] = {var = Menu.SliderInt("Anti Aim", state[i], "Yaw Add Left", 0, -180, 180), color = false}
        Tab["Anti Aim"]["custom_yaw_add_right_"..i..""] = {var = Menu.SliderInt("Anti Aim", state[i], "Yaw Add Right", 0, -180, 180), color = false}
        Tab["Anti Aim"]["custom_yaw_modifier_"..i..""] = {var = Menu.Combo("Anti Aim", state[i], "Yaw Modifier", {"Disabled", "Center", "Offset"}, 0), color = false}
        Tab["Anti Aim"]["custom_modifier_type_"..i..""] = {var = Menu.Combo("Anti Aim", state[i],"Modifier Type", {"Static","Ideal Jitter","Random Jitter"}, 0), color = false}
        Tab["Anti Aim"]["custom_modifier_degree_"..i..""] = {var = Menu.SliderInt("Anti Aim", state[i], "Modifier Degree", 0, -180, 180), color = false}
        Tab["Anti Aim"]["custom_modifier_jitter_"..i..""] = {var = Menu.SliderInt("Anti Aim", state[i], "Modifier Degree [2]", 50, -180, 180, ""), color = false}
        Tab["Anti Aim"]["custom_fake_type_"..i..""] = {var = Menu.Combo("Anti Aim", state[i],"Fake Type", {"Static","Ideal Jitter","Random Jitter","Custom Jitter"}, 0), color = false}
        Tab["Anti Aim"]["custom_fake_type_custom_"..i..""] = {var = Menu.Combo("Anti Aim", state[i], "Custom Fake Type", {"Ideal Jitter","Random Jitter",}, 0), color = false}
        Tab["Anti Aim"]["l_limit_"..i..""] = {var = Menu.SliderInt("Anti Aim", state[i], "Left Limit", 60, 0, 60), color = false}
        Tab["Anti Aim"]["r_limit_"..i..""] = {var = Menu.SliderInt("Anti Aim", state[i], "Right Limit", 60, 0, 60), color = false}
        Tab["Anti Aim"]["l_limit2_"..i..""] = {var = Menu.SliderInt("Anti Aim", state[i], "Left Limit [2]", 60, 0, 60), color = false}
        Tab["Anti Aim"]["r_limit2_"..i..""] = {var = Menu.SliderInt("Anti Aim",state[i], "Right Limit [2]", 60, 0, 60), color = false}
        Tab["Anti Aim"]["custom_options_"..i..""] = {var = Menu.MultiCombo("Anti Aim", state[i], "Fake Options", {"Avoid Overlap","Jitter","Randomize Jitter"}, 0), color = false}
        Tab["Anti Aim"]["custom_lby_"..i..""] = {var = Menu.Combo("Anti Aim", state[i], "LBY Mode", {"Disabled","Opposite","Sway"}, 0), color = false}
        Tab["Anti Aim"]["custom_fs_"..i..""] = {var = Menu.Combo("Anti Aim", state[i], "Freestanding Desync", {"Off","Peek Fake","Peek Real"}, 0), color = false}
        Tab["Anti Aim"]["custom_onshot_"..i..""] = {var = Menu.Combo("Anti Aim", state[i],"Desync On Shot", {"Disabled","Opposite","Freestanding","Switch"}, 0), color = false}
        warningroll = Menu.Text("Anti Aim", state[i], "                             Roll Exploit")
        Tab["Anti Aim"]["rae_"..i..""] = {var = Menu.Switch("Anti Aim", state[i], "Roll Angles", false, "ON/OFF Switch"), color = false}
        Tab["Anti Aim"]["ref_"..i..""] = {var = Menu.Combo("Anti Aim", state[i], "Roll Angle Type", {"Static", "Dynamic", "Random", "Custom"}, 0, "Static - Unique Value For The Roll Angle\n\nDynamic - Sways Between Min and Max Values\n\nRandom - Ramdomizes Between Min and Max Values\n\nCustom - Unique Custom Value For Both Sides Of The Roll Angles\n\nThe Exploit Only Activates on SlowWalk and Standing."), color = false}
        Tab["Anti Aim"]["custom_roll_left_"..i..""] = {var = Menu.SliderInt("Anti Aim",state[i], "Roll Left Angle", 0, 0, 160), color = false}
        Tab["Anti Aim"]["custom_roll_right_"..i..""] = {var = Menu.SliderInt("Anti Aim",state[i], "Roll Right Angle", 0, 0, 160), color = false}
        warninex = Menu.Text("Anti Aim", state[i], "Warning - When The Exploit is Turned On You Might Experience Movement Issues")

        aa[i] = 
        {
            custom_enable = Tab["Anti Aim"]["custom_enable_"..i..""].var,
            custom_pitch = Tab["Anti Aim"]["custom_pitch_"..i..""].var,
            custom_yaw_base = Tab["Anti Aim"]["custom_yaw_base_"..i..""].var,
            custom_yaw_add_left = Tab["Anti Aim"]["custom_yaw_add_left_"..i..""].var,
            custom_yaw_add_right = Tab["Anti Aim"]["custom_yaw_add_right_"..i..""].var,
            custom_yaw_modifier = Tab["Anti Aim"]["custom_yaw_modifier_"..i..""].var,
            custom_modifier_type = Tab["Anti Aim"]["custom_modifier_type_"..i..""].var,
            custom_modifier_degree = Tab["Anti Aim"]["custom_modifier_degree_"..i..""].var,
            custom_modifier_jitter = Tab["Anti Aim"]["custom_modifier_jitter_"..i..""].var,
            custom_fake_type = Tab["Anti Aim"]["custom_fake_type_"..i..""].var,
            custom_fake_type_custom = Tab["Anti Aim"]["custom_fake_type_custom_"..i..""].var,
            custom_left_limit = Tab["Anti Aim"]["l_limit_"..i..""].var,
            custom_right_limit = Tab["Anti Aim"]["r_limit_"..i..""].var,
            custom_left_limit2 = Tab["Anti Aim"]["l_limit2_"..i..""].var,
            custom_right_limit2 = Tab["Anti Aim"]["r_limit2_"..i..""].var,
            custom_options = Tab["Anti Aim"]["custom_options_"..i..""].var,
            custom_lby = Tab["Anti Aim"]["custom_lby_"..i..""].var,
            custom_fs = Tab["Anti Aim"]["custom_fs_"..i..""].var,
            custom_onshot = Tab["Anti Aim"]["custom_onshot_"..i..""].var,
            warningroll = warningroll,
            rae = Tab["Anti Aim"]["rae_"..i..""].var,
            ref = Tab["Anti Aim"]["ref_"..i..""].var,
            custom_roll_left = Tab["Anti Aim"]["custom_roll_left_"..i..""].var,
            custom_roll_right = Tab["Anti Aim"]["custom_roll_right_"..i..""].var,
            warningex = warninex,
        }
    end

    legitaa_check = function(...)

        local bomb = EntityList.GetEntitiesByName("CPlantedC4")
        local hostage = EntityList.GetEntitiesByName("CHostage")
        local door = EntityList.GetEntitiesByClassID(143)

        local lp = EntityList.GetLocalPlayer()
        local eyepos = lp:GetPlayer()

        local eyedist = eyepos:GetEyePosition()

            for bomb_i = 1, #bomb do
                local bomb2 = bomb[bomb_i]
                local bombdist = bomb2:GetRenderOrigin()
                local dist = (eyedist - bombdist):Length()
                if dist < 100 then
                    return true
                end
            end
                for hostage_i = 2, #hostage do
                    local hostage2 = hostage[hostage_i]
                    local hostagedist = hostage2:GetRenderOrigin()
                    local dist = (eyedist - hostagedist):Length()
                    if dist < 100 then
                        return true
                    end
                end
                    for door_i = 3, #door do
                        local door2 = door[door_i]
                        local doordist = door2:GetRenderOrigin()
                        local dist = (eyedist - doordist):Length()
                        if dist < 100 then
                            return true
                        end
                    end
        return false
    end


    hook_aa.update_jitter = function()
        if FakeLag.SentPackets() ~= 0 then
            jitter = jitter * -1
        end
    end

    hook_aa.new_condition = function(lp, cmd)

        local stateid = 1

        local flags = lp:GetProp("m_fFlags")

        if not aa[0].antiaims:Get() then
            -- unconditional
            return 9
        elseif aa[2].custom_enable:Get() and Cheat.IsKeyDown(0x45) and not legitaa_check() then
            --on use
            EngineClient.ExecuteClientCmd("-use")
            aa[0].manual:SetInt(0)
            return 2
        elseif aa[8].custom_enable:Get() and references.isSW:Get() then
            --slow walk
            return 8
        elseif aa[6].custom_enable:Get() and bit.band(flags, bit.lshift(1,0)) == 0 and lp:GetProp("m_flDuckAmount") > 0.8 then
            -- on air crouch
            return 6
        elseif aa[5].custom_enable:Get() and bit.band(flags, bit.lshift(1,0)) == 0 then
            --air
            return 5
        elseif aa[7].custom_enable:Get() and lp:GetProp("m_flDuckAmount") > 0.89 and bit.band(flags, 1) ~= 0 then
            --duck
            return 7
        elseif aa[4].custom_enable:Get() and not bit.band(flags, bit.lshift(1, 1)) ~= 0 and bit.band(flags, bit.lshift(1, 0)) ~= 0 and lp:GetProp("m_vecVelocity"):Length() > 2 then
            --move
            return 4
        elseif aa[3].custom_enable:Get() and lp:GetProp("m_vecVelocity"):Length() < 2 then
            --stand
            return 3
        else
            --shared
            return 1
        end

    end


    hook_aa.apply_condition = function(cmd)

        local localplayer = isvalidlp()

        if localplayer == nil then 
            return 
        end

        local stateid = hook_aa.new_condition(localplayer, cmd)

        references.aaenable:Set(true)
        references.options:Set(0)
        references.yaw_add:Set(0)
        references.yaw_modifier:Set(0)
        references.modifier_degree:Set(0)

        if not aa[stateid].rae:Get() then

            if aa[stateid].custom_enable:Get() or stateid == 9 or stateid == 1 then

                yaw, yaw_degree = 0, 0

                references.yaw_base:Set(aa[0].manual:Get() == 0 and aa[stateid].custom_yaw_base:Get() or aa[0].manual:Get()-1)

                if not antibruteforce.work then
                    if aa[stateid].custom_fake_type:Get() == 0 then
                        AntiAim.OverrideLimit(AntiAim.GetInverterState() and aa[stateid].custom_left_limit:Get() or aa[stateid].custom_right_limit:Get())
                    elseif aa[stateid].custom_fake_type:Get() == 1 then
                        AntiAim.OverrideLimit(jitter == 1 and 18 or AntiAim.GetInverterState() and aa[stateid].custom_left_limit:Get() or aa[stateid].custom_right_limit:Get())
                    elseif aa[stateid].custom_fake_type:Get() == 2 then
                        AntiAim.OverrideLimit(AntiAim.GetInverterState() and Utils.RandomInt(18, aa[stateid].custom_left_limit:Get()) or Utils.RandomInt(18, aa[stateid].custom_right_limit:Get()))
                    elseif aa[stateid].custom_fake_type:Get() == 3 then
                        if aa[stateid].custom_fake_type_custom:Get() == 0 then
                            AntiAim.OverrideLimit(jitter == 1 and (AntiAim.GetInverterState() and aa[stateid].custom_left_limit2:Get() or aa[stateid].custom_right_limit2:Get()) or (AntiAim.GetInverterState() and aa[stateid].custom_left_limit:Get() or aa[stateid].custom_right_limit:Get()))
                        elseif aa[stateid].custom_fake_type_custom:Get() == 1 then
                            AntiAim.OverrideLimit(AntiAim.GetInverterState() and Utils.RandomInt(aa[stateid].custom_left_limit:Get(), aa[stateid].custom_left_limit2:Get()) or Utils.RandomInt(aa[stateid].custom_right_limit:Get(), aa[stateid].custom_right_limit2:Get()))
                        end
                    end
                else
                    if antibruteforce_bool:Get() then
                        local phase = {}

                        for i = 0, (#antibruteforce.sliders_count - 1) do
                            phase[i] = Tab["Anti Bruteforce"]["phase_" .. (i + 1)].var:Get()
                        end

                        override_limit(phase[antibruteforce.cache[nearestenemy():EntIndex()].count], true)
                    else
                        return 
                    end
                end

                local yaw_add_mod = (AntiAim.GetInverterState() and aa[stateid].custom_yaw_add_left:Get() or aa[stateid].custom_yaw_add_right:Get())

                yaw = yaw + yaw_add_mod

                if aa[stateid].custom_options:Get(1) then
                    if math.min(math.abs(AntiAim.GetCurrentRealRotation() - AntiAim.GetFakeRotation()), AntiAim.GetMaxDesyncDelta()) < 20 then
                        AntiAim.OverrideInverter(not AntiAim.GetInverterState())
                    end
                end
                if aa[stateid].custom_options:Get(2) then 
                    if not aa[stateid].custom_options:Get(3) then
                        AntiAim.OverrideInverter(jitter == -1)
                    else
                        AntiAim.OverrideInverter(math.random(0,1) == 1)
                    end
                end

                if aa[stateid].custom_yaw_modifier:Get() == 1 then

                    if aa[stateid].custom_modifier_type:Get() == 0 then
                        yaw_degree = (aa[stateid].custom_modifier_degree:Get() / 2) * jitter
                    elseif aa[stateid].custom_modifier_type:Get() == 1 then
                        yaw_degree = ((jitter == 1 and aa[stateid].custom_modifier_degree:Get() or aa[stateid].custom_modifier_jitter:Get()) / 2) * jitter
                    elseif aa[stateid].custom_modifier_type:Get() == 2 then
                        yaw_degree = ((Utils.RandomInt(aa[stateid].custom_modifier_degree:Get(), aa[stateid].custom_modifier_jitter:Get())) / 2) * jitter
                    end

                elseif aa[stateid].custom_yaw_modifier:Get() == 2 then

                    if aa[stateid].custom_modifier_type:Get() == 0 then
                        yaw_degree = aa[stateid].custom_modifier_degree:Get() * ((jitter + 1) / 2)
                    elseif aa[stateid].custom_modifier_type:Get() == 1 then
                        yaw_degree = (jitter == 1 and aa[stateid].custom_modifier_degree:Get() or aa[stateid].custom_modifier_jitter:Get()) * ((jitter + 1) / 2)
                    elseif aa[stateid].custom_modifier_type:Get() == 2 then
                        yaw_degree = (Utils.RandomInt(aa[stateid].custom_modifier_degree:Get(), aa[stateid].custom_modifier_jitter:Get())) * ((jitter + 1) / 2)
                    end

                end

                yaw = yaw + yaw_degree
                
                AntiAim.OverrideYawOffset(yaw)

                references.pitch:Set(aa[stateid].custom_pitch:Get())
                references.lby_mode:Set(aa[stateid].custom_lby:Get())
                references.freestand:Set(aa[stateid].custom_fs:Get())
                references.onshot:Set(aa[stateid].custom_onshot:Get())
            end
        else
        
            AntiAim.OverrideYawOffset(0)

            if not aa[stateid].rae:GetBool() then
                return
            end
        
            if aa[stateid].ref:Get() == 0 then
                roll = references.inverter:Get() and -55 or 55
        
            elseif aa[stateid].ref:Get() == 1 then
                AntiAim.OverrideInverter(false)
                    if not sway_bool then
                        roll_sway = roll_sway + 1
                        if roll_sway >= 120 then
                            sway_bool = true
                        end
                    elseif sway_bool then
                        roll_sway = roll_sway - 1
                        if roll_sway <= 20 then
                            sway_bool = false
                        end
                    end
                roll = roll_sway
            
            elseif aa[stateid].ref:Get() == 2 then
                roll = references.inverter:Get() and Utils.RandomInt(1, 159) or Utils.RandomInt(-159, -1)
        
            elseif aa[stateid].ref:Get() == 3 then
                roll = references.inverter:Get() and aa[stateid].custom_roll_right:Get() or aa[stateid].custom_roll_left:Get()*-1
            end

            cmd.viewangles.roll = roll

            references.pitch:Set(aa[stateid].custom_pitch:Get())
            references.lby_mode:Set(aa[stateid].custom_lby:Get())
            references.freestand:Set(aa[stateid].custom_fs:Get())
            references.onshot:Set(aa[stateid].custom_onshot:Get())
        end
    end

    aa[1].custom_enable:Set(true)

-- @end_region = Anti Aim Builder 


-- @region = Random Shit 0_0

    Menu.Text("Info","Info/Issues", "If you have any problems with the script contact me via ticket in my discord server.\n\nDont forget, if you like the lua and want more updates and features make sure to leave a rating on the market page! :D")

-- @end_region = Random Shit 0_0


-- @region = Auto Teleport In Air

    local auto_teleport = {}

    Tab["Anti Aim"].airtp_bool = {
        var = Menu.Switch("Anti Aim", "Anti-Aim Features", "Auto Teleport In Air", false, "ON/OFF Switch"),
        color = false
    }

    Tab["Anti Aim"].airtp_mcombo = {
        var = Menu.MultiCombo("Anti Aim", "Anti-Aim Features", "Teleport Weapons", {"Scout", "AWP", "Pistols", "Zeus", "Knife", "Nades", "Other"}, 0),
        color = false
    }

    auto_teleport.createmove = function()

        if not Tab["Anti Aim"].airtp_bool.var:Get() then
            return
        end

        if not references.doubletap:Get() then
            return
        end

        if Tab["Anti Aim"].airtp_mcombo.var:Get() == 0 then
            return
        end

        local Allow_Work = false
        local Need_Teleport = false

        local Localplayer = EntityList.GetLocalPlayer()
        local Weapon = Localplayer:GetActiveWeapon()

        if Weapon == nil then
            return
        end

        local WeaponID = Weapon:GetWeaponID()

        local IsScout = WeaponID == 40
        local IsAWP = WeaponID == 9
        local IsPistols = Weapon:IsPistol()
        local IsZeus = WeaponID == 31
        local IsKnife = Weapon:IsKnife()
        local IsNades = Weapon:IsGrenade()

        for i, Weapons in pairs({
            IsScout,
            IsAWP,
            IsPistols,
            IsZeus,
            IsKnife,
            IsNades,
            not (IsScout or IsAWP or IsPistols or IsZeus or IsKnife or IsNades)
        }) do
            if (Tab["Anti Aim"].airtp_mcombo.var:Get(i) and Weapons) then
                Allow_Work = true
            end
        end

        if not Allow_Work then
            return
        end

        for _, Enemy in pairs(GetEnemies()) do

            if Enemy == nil then
                return
            end

            if (not Enemy:IsDormant() and CanHit(Enemy)) then
                if not GetFlag(Localplayer, 0) then
                    Exploits.ForceTeleport()
                end
            end

        end
    end

-- @end_region = Auto Teleport In Air


-- @region = Console Color Changer

    local console = {}

    Tab["Misc"].consoleCol_bool = {
        var = Menu.SwitchColor("Misc", "Misc", "Console Color", false, Color.new(1.0, 1.0, 1.0)),
        color = true
    }

    console.engineClient = Utils.CreateInterface("engine.dll", "VEngineClient014")
    console.engineClientClass = ffi.cast(ffi.typeof("void***"), console.engineClient)
    console.isVisible = ffi.cast("bool(__thiscall*)(void*)", console.engineClientClass[0][11])

    console.Materials = {"vgui_white", "vgui/hud/800corner1", "vgui/hud/800corner2", "vgui/hud/800corner3", "vgui/hud/800corner4"}
    console.materialList = {}

    console.oldColor = Color.new(1.0, 1.0, 1.0, 1.0)
    console.oldIsVisible = false

    console.findMaterials = function()
        
        if console.materialList[1] then 
            return 
        end

        local material = MatSystem.FirstMaterial()
        local foundCount = 0

        while(foundCount < 5)
        do
            local mat = MatSystem.GetMaterial(material)
            local name = mat:GetName()

            for i = 1, #console.Materials do
                if name == console.Materials[i] then
                    console.materialList[i] = mat
                    foundCount = foundCount + 1
                    break
                end
            end

            material = MatSystem.NextMaterial(material)
        end
    end

    console.updateConsoleColor = function(r, g, b, a)
        for i = 1, #console.materialList do
            local mat = console.materialList[i]
            mat:ColorModulate(r, g, b)
            mat:AlphaModulate(a)
        end
    end

    console.cfgCallback = function()

        if not Tab["Misc"].consoleCol_bool.var:Get() or not misc_bool:Get() then
            console.updateConsoleColor(1, 1, 1, 1)
        elseif console.isVisible(engineClientClass) then
            local console_col = Tab["Misc"].consoleCol_bool.var:GetColor()

            console.updateConsoleColor(console_col.r, console_col.g, console_col.b, console_col.a)
            copyColor(console_col, console.oldColor)
        end

    end

    console.color_draw = function()

        if not Tab["Misc"].consoleCol_bool.var:Get() or not misc_bool:Get() then 
            return
        end

        console.findMaterials()

        console_col = Tab["Misc"].consoleCol_bool.var:GetColor()
        local consoleVisible = console.isVisible(engineClientClass)

        if consoleVisible and not isColorEquals(console.oldColor, console_col) then
            console.updateConsoleColor(console_col.r, console_col.g, console_col.b, console_col.a)
            copyColor(console_col, console.oldColor)
        end

        if consoleVisible ~= console.oldIsVisible then
            if not consoleVisible then 
                console.updateConsoleColor(1, 1, 1, 1)
            else
                console.updateConsoleColor(console_col.r, console_col.g, console_col.b, console_col.a)
            end

            console.oldIsVisible = consoleVisible
        end
    end

    Tab["Misc"].consoleCol_bool.var:RegisterCallback(console.cfgCallback)
    Tab["Misc"].misc_bool.var:RegisterCallback(console.cfgCallback)
    console.cfgCallback()

-- @end_region = Console Color Changer


-- @region = Notifications & Hit Miss Logs

Tab["Misc"].hitlogs_bool = {var = Menu.Switch("Misc", "Misc", "Hit/Miss Logs", false, "Simple Hit/Miss logs"), color = false}
Tab["Misc"].hitlogs_mcombo = {var = Menu.MultiCombo("Misc", "Misc", "Log Mode", {"Notification", "Console", "Events"}, 0, "Notification - Renders a notification on the bottom of the screen\n\nConsole - Prints the info on console\n\nEvents - Info will appear in the top left corner of the screen"), color = false}
Tab["Misc"].hitlogs_notColor = {var = Menu.ColorEdit("Misc", "Misc", "Notification Log Color", Color.RGBA(255,255,255,255)), color = true}
Tab["Misc"].hitlogs_consColor = {var = Menu.ColorEdit("Misc", "Misc", "Console Log Color", Color.RGBA(255,255,255,255)), color = true}
Tab["Misc"].hitlogs_resolv = {var = Menu.ColorEdit("Misc", 'Misc', 'Console Miss Resolver Color',Color.RGBA(255,255,255,255)), color = true}
Tab["Misc"].hitlogs_spread = {var = Menu.ColorEdit("Misc", 'Misc', 'Console Miss Spread Color',Color.RGBA(255,255,255,255)), color = true}
Tab["Misc"].hitlogs_prederr = {var = Menu.ColorEdit("Misc", 'Misc', 'Console Miss Pred. error Color',Color.RGBA(255,255,255,255)), color = true}

local shot_number = 0

concatenate_text = function (argumentos)
    local texto = ""
    for i=1, #argumentos do
        texto = texto .. argumentos[i].text
    end
    return texto
end

hitmisslogs = function()

    if #logs > 0 then

        if #logs > 6 then
            table.remove(logs, 1)
        end

        local textsize = 0
        local width_offset = 0
        x = logs.x
        y = logs.y

        if GlobalVars.realtime >= (logs[1][2]+3) then
            if logs[1][3] > 0 then
                logs[1][3] = logs[1][3] - 2
            elseif logs[1][3] <= 0 then
                table.remove(logs, 1)
            end
        end
    
        for i = 1, #logs do

            width_offset = 0

            if logs[i][3] < 255 then 
                logs[i][3] = logs[i][3] + 1 
            end

            for k = 1, #logs[i][1] do
                text_for_concat = concatenate_text(logs[i][1])
                textsize = Render.CalcTextSize(text_for_concat, 11, font.verdana11r)

                r = math_round(logs[i][1][k].color.r * 255)
                g = math_round(logs[i][1][k].color.g * 255)
                b = math_round(logs[i][1][k].color.b * 255)
                a = math_round(logs[i][1][k].color.a * 255)

                Render.Text(logs[i][1][k].text, Vector2.new(math.min(50, logs[i][3]*1)-49 + engine_client.screen_size.x/2-textsize.x/2 + width_offset, engine_client.screen_size.y-194-24*i), Color.RGBA(0,0,0, math.min(255, logs[i][3]*5)), 11, font.verdana11r)
                Render.Text(logs[i][1][k].text, Vector2.new(math.min(50, logs[i][3]*1)-50 + engine_client.screen_size.x/2-textsize.x/2 + width_offset, engine_client.screen_size.y-195-24*i), Color.RGBA(r, g, b, math.min(255, logs[i][3]*5)), 11, font.verdana11r)

                width_offset = width_offset + Render.CalcTextSize(logs[i][1][k].text, 11, font.verdana11r).x
            end
        end
    end
end



printMissInfo = function(shot)

    if not misc_bool:Get() or not Tab["Misc"].hitlogs_bool.var:Get() then
        return
    end

    local enemy = EntityList.GetClientEntity(shot.target_index)
    local ent_name = enemy:GetPlayer():GetName()

    reason = shot.reason

    if reason == 3 then
        reason = 2 
    end

    if reason == 0 then

        shot_number = shot_number + 1
        if shot_number > 100 then 
            shot_number = 0 
        end

        if Tab["Misc"].hitlogs_mcombo.var:Get(2) then
            color_print(Tab["Misc"].hitlogs_consColor.var:GetColor(),"[VALENCY] ")
            color_print(Color.RGBA(255, 255, 255, 255),string.format("Registered %dth shot at %s's %s for %d damage | hc [%d] bt [%dms]\n", shot_number, ent_name, logs.hitgroups[shot.hitgroup+1], shot.damage, shot.hitchance, shot.backtrack))
        end

        if Tab["Misc"].hitlogs_mcombo.var:Get(3) then
            Cheat.AddEvent(string.format("[VALENCY] Hit %s's %s for %d damage | hc [%d] bt [%dms]", ent_name, logs.hitgroups[shot.hitgroup+1], shot.damage, shot.hitchance, shot.backtrack))
        end

    else

        if Tab["Misc"].hitlogs_mcombo.var:Get(1) then
            logs[#logs+1] = {
                {
                    {
                        text = "[VALENCY] ",
                        color = Color.RGBA(shot.reason == 2 and 255 or shot.reason == 1 and 255 or 210, shot.reason == 2 and 196 or shot.reason == 1 and 0 or 255, shot.reason == 2 and 0 or 0, 255)
                    },
                    {
                        text = "Missed ",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = ""..ent_name.."",
                        color = Color.RGBA(shot.reason == 2 and 255 or shot.reason == 1 and 255 or 210, shot.reason == 2 and 196 or shot.reason == 1 and 0 or 255, shot.reason == 2 and 0 or 0, 255)
                    },
                    {
                        text = "'s ",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = ""..logs.hitgroups[shot.wanted_hitgroup+1].." ",
                        color = Color.RGBA(shot.reason == 2 and 255 or shot.reason == 1 and 255 or 210, shot.reason == 2 and 196 or shot.reason == 1 and 0 or 255, shot.reason == 2 and 0 or 0, 255)
                    },  
                    {
                        text = "due to ",
                        color = Color.RGBA(255, 255, 255, 255)
                    },           
                    {
                        text = ""..logs.reason[shot.reason].." ",
                        color = Color.RGBA(shot.reason == 2 and 255 or shot.reason == 1 and 255 or 210, shot.reason == 2 and 196 or shot.reason == 1 and 0 or 255, shot.reason == 2 and 0 or 0, 255)
                    },   
                    {
                        text = "(",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = ""..shot.hitchance.."",
                        color = Color.RGBA(shot.reason == 2 and 255 or shot.reason == 1 and 255 or 210, shot.reason == 2 and 196 or shot.reason == 1 and 0 or 255, shot.reason == 2 and 0 or 0, 255)
                    },
                    {
                        text = "% HC)",
                        color = Color.RGBA(255, 255, 255, 255)
                    }, 
                }, GlobalVars.realtime, 0,
            }
        end

        if Tab["Misc"].hitlogs_mcombo.var:Get(2) then
            if reason == 1 then
                color_print(Tab["Misc"].hitlogs_consColor.var:GetColor(),"[VALENCY] ")
                color_print(Color.RGBA(255, 255, 255, 255),string.format("Missed shot in %s's %s due to ", ent_name, logs.hitgroups[shot.wanted_hitgroup+1]))
                color_print(Tab["Misc"].hitlogs_resolv.var:GetColor(),string.format("%s", logs.reason[shot.reason]))
                color_print(Color.RGBA(255, 255, 255, 255),string.format(" | hc [%d] bt [%dms]\n", shot.hitchance, shot.backtrack))
            elseif reason == 2 then
                color_print(Tab["Misc"].hitlogs_consColor.var:GetColor(),"[VALENCY] ")
                color_print(Color.RGBA(255, 255, 255, 255),string.format("Missed shot in %s's %s due to ", ent_name, logs.hitgroups[shot.wanted_hitgroup+1]))
                color_print(Tab["Misc"].hitlogs_spread.var:GetColor(),string.format("spread [%.2f]\n", shot.spread_degree))
            elseif reason == 4 then
                color_print(Tab["Misc"].hitlogs_consColor.var:GetColor(),"[VALENCY] ")
                color_print(Color.RGBA(255, 255, 255, 255),string.format("Missed shot in %s's %s due to ", ent_name, logs.hitgroups[shot.wanted_hitgroup+1]))
                color_print(Tab["Misc"].hitlogs_prederr.var:GetColor(),string.format("%s", logs.reason[shot.reason]))
                color_print(Color.RGBA(255, 255, 255, 255),string.format(" | hc [%d] bt [%dms]\n", shot.hitchance, shot.backtrack))
            end
        end

        if Tab["Misc"].hitlogs_mcombo.var:Get(3) then
            Cheat.AddEvent(string.format("[VALENCY] Missed shot in %s's %s due to %s | spread [%.2f] hc [%d] bt [%dms]", ent_name, logs.hitgroups[shot.wanted_hitgroup+1], logs.reason[shot.reason], shot.spread_degree, shot.hitchance, shot.backtrack))
        end

    end
end

printHitInfo = function(event)

    if not misc_bool:Get() or not Tab["Misc"].hitlogs_bool.var:Get() and not Tab["Misc"].hitlogs_mcombo.var:Get(1) then
        return
    end

    if event:GetName() ~= "player_hurt" then
        return
    end

    local victim = EntityList.GetPlayerForUserID(event:GetInt("userid", -1))
    local attacker = EntityList.GetPlayerForUserID(event:GetInt("attacker", -1))

    if attacker == nil then
        return
    end

    if attacker:EntIndex() ~= EngineClient.GetLocalPlayer() or victim == attacker then
        return
    end

    local hitgroup = event:GetInt("hitgroup")
    local enemy_name = victim:GetName()

    local damage = event:GetInt("dmg_health", -1)
    local remaining_health = event:GetInt("health")
    local weapon = event:GetString("weapon")

    logs[#logs+1] = {
        {
            {
                text = "[VALENCY] ",
                color = Color.RGBA(199, 255, 0, 255)
            },
            {
                text = "Hit ",
                color = Color.RGBA(255, 255, 255, 255)
            },
            {
                text = string.format("%s ", enemy_name),
                color = Color.RGBA(199, 255, 0, 255)
            },
            {
                text = "in the ",
                color = Color.RGBA(255, 255, 255, 255)
            },
            {
                text = ""..logs.hitgroups[hitgroup+1].." ",
                color = Color.RGBA(199, 255, 0, 255)
            },  
            {
                text = "for ",
                color = Color.RGBA(255, 255, 255, 255)
            },           
            {
                text = ""..damage.." ",
                color = Color.RGBA(199, 255, 0, 255)
            },    
            {
                text = "damage (",
                color = Color.RGBA(255, 255, 255, 255)
            },
            {
                text = ""..remaining_health.." ",
                color = Color.RGBA(199, 255, 0, 255)
            },
            {
                text = "health remaining)",
                color = Color.RGBA(255, 255, 255, 255)
            },   
        }, GlobalVars.realtime, 0,
    }
end

-- @end_region = Notifications & Hit Miss Logs


-- @region = Clantag Changer

    local clantag = {}

    Tab["Misc"].clantag_bool = {
        var = Menu.Switch("Misc", "Misc", "Clantag", false, "Activates The Lua Styled Clantag."), 
        color = false
    }

    clantag.fn_change_clantag = Utils.PatternScan("engine.dll", "53 56 57 8B DA 8B F9 FF 15")
    clantag.set = ffi.cast("clantag_t", clantag.fn_change_clantag)

    clantag.last_iter = -1
    clantag.string =
    {
        "v            ",
        "va           ",
        "val          ",
        "vale         ",
        "valen        ",
        "valenc       ",
        "valency      ",
        "valency.     ",
        "valency.l    ",
        "valency.lu   ",
        "valency.lua  ",
        "valency.lua   ",
        "|valency.lua ",
        "v|alency.lua ",
        "va|lency.lua ",
        "val|ency.lua ",
        "vale|ncy.lua ",
        "valen|cy.lua ",
        "valenc|y.lua ",
        "valency|.lua ",
        "valency.|lua ",
        "valency.l|ua ",
        "valency.lu|a ",
        "valency.lua| ",
        "valency.lua| ",
        "valency.lu|a ",
        "valency.l|ua ",
        "valency.|lua ",
        "valency|.lua ",
        "valenc|y.lua ",
        "valen|cy.lua ",
        "vale|ncy.lua ",
        "val|ency.lua ",
        "va|lency.lua ",
        "v|alency.lua ",
        "|valency.lua ",
        "valency.lua  ",
        "valency.lua  ",
        "valency.lua  ",
        "valency.lua  ",
        "valency.lua  ",
        "valency.lua  ",
        "valency.lua  ",
        "valency.lua  ",
        "valency.lua  ",
        "alency.lua   ",
        "lency.lua    ",
        "ency.lua     ",
        "ncy.lua      ",
        "cy.lua       ",
        "u.lua        ",
        ".lua         ",
        "lua          ",
        "ua           ",
        "a            ",
        "             ",
    }

    mod = function(a, b)
        return a - math.floor(a/b)*b
    end

    clantag.restore = Menu.FindVar("Miscellaneous", "Main", "Spammers", "Clantag")
    clantag.running = false

    clantag.draw = function()
        if not Tab["Misc"].clantag_bool.var:Get() or not misc_bool:Get() then
            return
        end
            
        if clantag.restore:Get() == true then
            clantag.restore:Set(false)
        end
        
        if EngineClient.IsConnected() then
            local netchann_info = EngineClient.GetNetChannelInfo()
            if netchann_info == nil then 
                return
            end
            
            local raw_latency = netchann_info:GetLatency(0)
            local latency = raw_latency / GlobalVars.interval_per_tick
            local tickcount_pred = GlobalVars.tickcount + latency
            local iter = math.floor(mod(tickcount_pred / 15.45, #clantag.string))
            
            if iter ~= clantag.last_iter then 
                clantag.running = true
                local tag = clantag.string[iter]
                clantag.set(tag, tag)
                clantag.last_iter = iter
            end
        end
    end

    clantag.clean = function()
        if not clantag.running then
            return
        end
        clantag.set("", "")
    end

    Tab["Misc"].clantag_bool.var:RegisterCallback(function()
        clantag.clean()
    end) 
    Tab["Misc"].misc_bool.var:RegisterCallback(function()
        clantag.clean()
    end) 

-- @end_region = Clantag Changer


-- @region = Killsay

    local killsay = {}

    Tab["Misc"].trashtalk_bool = {
        var = Menu.Switch("Misc", "Misc", "Trashtalk", false, "Auto Trashtalk People On Kill!"), 
        color = false
    }

    killsay.phrases = {
        "%s, facil com valency.lua",
        "%s, valency.lua, let it carry you!",
        "%s, haha viste? ganda bala fogo",
        "%s, valency.lua best lua",
        "%s,  valency.lua ",
        "%s, CHEAT BOOSTED? MENTIRA JUST VALENCY.LUA SCRIPT OH TONE",
        "%s, valency tank owning rezolver.lua best nl lua script [publico v2.1]", 
        "%s, hs bot",
        "%s, die iqless walkbot",
        "%s, ez f12",
        "%s, 0 iq",
        "?",
        "%s, sleep",
        "    ",	
        "%s, dead people can't talk nn",
        "%s, let my K/D do the talking",
        "%s, mad cuz bad",
        "%s, iq ? HAHAHA",
        "%s, nice anti-aim bro",
        "%s, desculpa clicar no W, valency.lua permite-me faz-lo.",
        "%s, desculpa mas nao uso gaja script nenhuma mas sim valency.lua",
        "%s, nu tem valency.lua levas ti bala nha manu",
        "%s, com valency.lua at parece que a minha %s d menos misses",
        "%s, a minha config de %s  superior porque eu estou com valency.lua?",	
        "%s, no tens valency.lua no s nada seu macaco.",
        "%s, 1 seu macaco",	
        "%s, andamento",		
        "%s, How you can tap? ... go sleep... go sleep",	
    }

    killsay.deathphrases = {	
        "%s, you are lucky bot",
        "%s, why are you scared",
        "%s, gave you that one",
        "%s, you are so fucking lucky"
    }

    killsay.get_phrase = function()
        return killsay.phrases[Utils.RandomInt(1, #killsay.phrases)]:gsub('"', '')
    end

    killsay.get_deathphrase = function()
        return killsay.deathphrases[Utils.RandomInt(1, #killsay.deathphrases)]:gsub('"', '')
    end

    killsay.event = function(event)

        if not misc_bool:Get() or not Tab["Misc"].trashtalk_bool.var:Get() then
            return
        end

        if event:GetName() ~= "player_death" then 
            return 
        end

        local me = EntityList.GetLocalPlayer()
        local victim = EntityList.GetPlayerForUserID(event:GetInt("userid"))
        local attacker = EntityList.GetPlayerForUserID(event:GetInt("attacker"))

        if attacker == me and victim ~= me then

            local lpweapon = me:GetActiveWeapon()

            if lpweapon == nil then 
                return 
            end

            local weapon_id = lpweapon:GetWeaponID()

            local IsScout = weapon_id == 40
            local IsAWP = weapon_id == 9
            local IsPistols = lpweapon:IsPistol()
            local IsZeus = weapon_id == 31
            local IsKnife = lpweapon:IsKnife()
            local IsNades = lpweapon:IsGrenade()
            local weaponname = ""
                                                    
            if IsScout then
                weaponname = "scout"
            elseif IsAwp then
                weaponname = "awp"
            elseif IsPistols then
                weaponname = "pistola"
            elseif IsZeus then
                weaponname = "zeus"
            elseif IsKnife then
                weaponname = "knife"
            elseif IsNades then
                weaponname = "nade"
            else
                weaponname = "arma"
            end
            
            EngineClient.ExecuteClientCmd(string.format('say "' .. killsay.get_phrase() .. '"', victim:GetName(), weaponname))

        elseif victim == me and attacker ~= me then

            EngineClient.ExecuteClientCmd(string.format('say "' .. killsay.get_deathphrase() .. '"', attacker:GetName()))
        
        end
    end

-- @end_region = Killsay


-- @region = Anti Backstab

    local anti_backstab = {}

    Tab["Anti Aim"].antibackstab_bool = {
        var = Menu.Switch("Anti Aim", "Anti-Aim Features", "Avoid Backstab", false, "Turns your direction towards the enemy so they can't backstab you."), 
        color = false
    }
    Tab["Anti Aim"].antibackstab_mcombo = {
        var = Menu.Combo("Anti Aim", "Anti-Aim Features", "Change To Weapon:", {"Disabled", "Secondary", "Zeus"}, 0, "Changes your gun to your secondary weapon/zeus if enemy is rushing you with a knife."), 
        color = false
    }

    anti_backstab.prediction = function()

        if not Tab["Anti Aim"].antibackstab_bool.var:Get() then
            return
        end

        for _, Enemy in pairs(GetEnemies()) do

            if Enemy == nil then
                return
            end

            if Enemy:IsDormant() then
                return
            end

            local active_weapon = Enemy:GetActiveWeapon()

            if active_weapon == nil then
                return
            end
            
            if not active_weapon:IsKnife() then
                return
            end

            if EntityList.GetLocalPlayer():GetRenderOrigin():DistTo(Enemy:GetRenderOrigin()) < 300 then

                AntiAim.OverrideYawOffset(yaw + 180)

                if Tab["Anti Aim"].antibackstab_mcombo.var:Get() == 1 then
                    EngineClient.ExecuteClientCmd("slot2")
                elseif Tab["Anti Aim"].antibackstab_mcombo.var:Get()==2 then
                    EngineClient.ExecuteClientCmd("use weapon_taser")
                end
            end
        end     
    end

-- @end_region = Anti Backstab


-- @region = Force Onshot

    local force_onshot = {}

    Tab["Anti Aim"].forceonshot_bool = {
        var = Menu.Switch("Anti Aim", "Anti-Aim Features", "Force On-Shot", false, "When Activated The Cheat Will Not Shoot Until Enemy Shoots."), 
        color = false
    }

    force_onshot.LastShotTime = {}

    force_onshot.on_event = function(event)

        if not Tab["Anti Aim"].forceonshot_bool.var:Get() then
            return
        end

        if (event:GetName() == "weapon_fire") then

            enemy_id = event:GetInt("userid")
            if enemy_id == nil then
                return
            end

            enemy_index = EntityList.GetPlayerForUserID(enemy_id):EntIndex()
            if enemy_index == nil then
                return
            end

            force_onshot.LastShotTime[enemy_index] = GlobalVars.tickcount
        end
    end

    force_onshot.on_prediction = function()

        if not Tab["Anti Aim"].forceonshot_bool.var:Get() then
            return
        end

        for _, Enemy in pairs(GetEnemies()) do

            if Enemy == nil then
                return
            end

            local EnemyIndex = Enemy:EntIndex()

            if ((force_onshot.LastShotTime[EnemyIndex] or 0) + 8 <= GlobalVars.tickcount) then
                RageBot.IgnoreTarget(EnemyIndex)
            end
        end
    end

-- @end_region = Force Onshot


-- @region = Disable FakeLag On Hideshots / Ideal Tick

    local floff_onhs = {}

    Tab["Anti Aim"].adjustfl_bool = {
        var = Menu.Switch("Anti Aim", "Anti-Aim Features", "Adjust FakeLag Limit", false, "When Activated The Cheat Will Disable Fakelag When Hideshots Exploit Is On."), 
        color = false
    }

    floff_onhs.fl_restore = references.fl_limit:Get()
    floff_onhs.fl_random_restore = references.fl_random:Get()

    floff_onhs.toggle = function()

        if references.hideshot:Get() and Tab["Anti Aim"].adjustfl_bool.var:Get() then
            floff_onhs.fl_restore = references.fl_limit:Get()
            floff_onhs.fl_random_restore = references.fl_random:Get()
            references.fl_limit:Set(1)
            references.fl_random:Set(0)
        else
            floff_onhs.restore_fl()
        end

    end

    floff_onhs.restore_fl = function()

        references.fl_limit:Set(floff_onhs.fl_restore)
        references.fl_random:Set(floff_onhs.fl_random_restore)
        
    end

    Tab["Anti Aim"].adjustfl_bool.var:RegisterCallback(floff_onhs.toggle)
    references.hideshot:RegisterCallback(floff_onhs.toggle)
    floff_onhs.toggle()

-- @end_region = Disable FakeLag On Hideshots / Ideal Tick


-- @region = Anti Defensive

    local anti_defensive = {}

    Tab["Global"].ax_bool = {
        var = Menu.Switch("Global", "Global", "Anti-Defensive", false, "Turn on to turn off backtrack and insta predic enemies\n\nThis works without going into spectator."), 
        color = false
    }

    anti_defensive.lag_comp = CVar.FindVar("cl_lagcompensation")

    anti_defensive.toogle = function()
        if global_bool:Get() and Tab["Global"].ax_bool.var:Get() then
            anti_defensive.lag_comp:SetInt(0)
        else
            anti_defensive.lag_comp:SetInt(1)
        end
    end

    anti_defensive.destroy = function()
        anti_defensive.lag_comp:SetInt(1)
    end

    anti_defensive.toogle()
    Tab["Global"].ax_bool.var:RegisterCallback(anti_defensive.toogle)
    Tab["Global"].global_bool.var:RegisterCallback(anti_defensive.toogle)

-- @end_region = Anti Defensive


-- @region = Hitchance In Air And Hitchance On Noscope And Doubletap Speed

    ----- hc on air / noscope

        local hitchance = {}

        Tab["Global"].hcair_bool = {var = Menu.Switch("Global", "Global", "Custom Air Hitchance", false, "ON/OFF Switch"),  color = false}
        Tab["Global"].hcair_slider = {var = Menu.SliderInt("Global", "Global", "Air Hitchance", 50, 0, 100, "Hitchance when you are on air."),  color = false}
        Tab["Global"].hcnoscope_bool = {var = Menu.Switch("Global", "Global", "Custom Noscope Hitchance", false, "ON/OFF Switch"),  color = false}
        Tab["Global"].hcnoscope_slider = {var = Menu.SliderInt("Global", "Global", "Noscope Hitchance", 50, 0, 100, "Hitchance when you aren't scoped."),  color = false}

        hitchance.air = function()

            if not global_bool:Get() or not Tab["Global"].hcair_bool.var:Get() then
                return
            end

            local localplayer = isvalidlp()

            if localplayer == nil then 
                return 
            end

            local onGround = bit.band(localplayer:GetProp("DT_BasePlayer", "m_fFlags"), bit.lshift(1,0)) ~= 0

            if onGround then
                return
            end

            for i = 1, #EntityList.GetPlayers() do
                RageBot.OverrideHitchance(i, Tab["Global"].hcair_slider.var:Get())
            end
        end

        hitchance.noscope = function()

            if not global_bool:Get() or not Tab["Global"].hcnoscope_bool.var:Get() then
                return
            end

            local localplayer = isvalidlp()

            if localplayer == nil then 
                return 
            end

            local scoped = localplayer:GetProp("m_bIsScoped")

            if scoped then
                return
            end

            local active_weapon = localplayer:GetActiveWeapon()

            if active_weapon == nil then 
                return 
            end

            active_weapon = active_weapon:GetWeaponID()

            if not active_weapon == 40 or not active_weapon == 9 or not active_weapon == 11 then
                return
            end

            for i = 1, #EntityList.GetPlayers() do
                RageBot.OverrideHitchance(i, Tab["Global"].hcnoscope_slider.var:Get())
            end
        end

    -----

    -----dt

        local doubletap_speed = {}

        Tab["Global"].dtspeed_bool = {
            var = Menu.Switch("Global", "Global", "Change DT Speed", false, "ON/OFF Switch"),
            color = false
        }
        Tab["Global"].dtspeed_slider = {
            var = Menu.SliderInt("Global", "Global", "DT Speed", 13, 13, 16, "Select DoubleTap ticks\n\nLow Value - Safe But Slow\n\nHigh Value - Unsafer But Faster"),  
            color = false
        }

        doubletap_speed.prediction = function()

            if not global_bool or not Tab["Global"].dtspeed_bool.var:Get() then
                return
            end

            local localplayer = isvalidlp()

            if localplayer == nil then 
                return 
            end

            Exploits.OverrideDoubleTapSpeed(Tab["Global"].dtspeed_slider.var:Get()) 
            CVar.FindVar("sv_maxusrcmdprocessticks"):SetInt(Tab["Global"].dtspeed_slider.var:Get() + 2)
        end

    ------

-- @end_region = Hitchance In Air And Hitchance On Noscope And Doubletap Speed



-- @region = Dormant Aimbot

    local dormant_aimbot = {}

    Tab["Global"].dormantaimbot_bool = {
        var = Menu.Switch("Global", "Global", "Dormant Aimbot", false, "ON/OFF Switch"),
        color = false
    }
    Tab["Global"].dormantaimbot_slider = {
        var = Menu.SliderInt("Global", "Global", "Minimum Damage", 1, 1, 100, "Recommended 1 Min Damage"),
        color = false
    }

    local min = Vector.new()
    local max = Vector.new()

    dormant_aimbot.prediction = function(cmd)

        if not Tab["Global"].dormantaimbot_bool.var:Get() or not global_bool:Get() then
            return
        end

        local localplayer = isvalidlp()

        if localplayer == nil then 
            return 
        end

        local me = localplayer
        local weap = me:GetActiveWeapon()

        if weap == nil then
            return
        end

        local weapon_id = weap:GetWeaponID()

        local dormant_target = GetDormantEnemy()
        local weap_delay = (weapon_id == 9 or weapon_id == 40) and 0.15 or 0.0

        if dormant_target and weap_delay and weap:GetProp("m_flNextPrimaryAttack") and GlobalVars.curtime and weap:GetProp("m_flNextPrimaryAttack") + weap_delay <= GlobalVars.curtime and me:GetProp("m_bIsScoped") then

            local bounds = dormant_target:GetRenderBounds(min, max)
            local pos = dormant_target:GetProp("m_vecOrigin") + Vector.new((min.x + max.x)/4, (min.y + max.y)/16, (min.z + max.z/2))

            if Cheat.FireBullet(me, me:GetEyePosition(), pos).damage >= Tab["Global"].dormantaimbot_slider.var:Get() then

                auto_stop(me, cmd)

                if 1 / weap:GetInaccuracy(weap) >= 100 then
                    local getaimpunch = me:GetProp("DT_BasePlayer", "m_aimPunchAngle")
                    local aimpunch = QAngle.new(getaimpunch.x, getaimpunch.y, 0.0)
                    local aim_angle = calculate_angle(me:GetEyePosition(), pos)
                    cmd.viewangles.pitch = aim_angle.pitch - aimpunch.pitch * 2
                    cmd.viewangles.yaw = aim_angle.yaw - aimpunch.yaw * 2
                    cmd.buttons = bit.bor(cmd.buttons, 1)
                end
            end
        end
    end

-- @end_region = Dormant Aimbot


-- @region = Force Baim If Lethal

    local forcebaim_lethal = {}

    Tab["Global"].forcebaimonlethal_bool = {
        var = Menu.Switch("Global","Global", "Force Baim If Enemy Lethal", false, "When Activated The Cheat Will Force Baim If Target Enemy Is Lethal."),
        color = false
    }

    forcebaim_lethal.RageBot_head = function(ent, state)
        RageBot.EnableHitbox(ent, 0, state)
        RageBot.EnableMultipoints(ent, 0, state)
        RageBot.EnableHitbox(ent, 1, state)
        RageBot.EnableMultipoints(ent, 1, state)
    end
        
    forcebaim_lethal.RageBot_baim = function(ent, state)
        RageBot.EnableHitbox(ent, 2, state)
        RageBot.EnableMultipoints(ent, 2, state)
        RageBot.EnableHitbox(ent, 3, state)
        RageBot.EnableMultipoints(ent, 3, state)
        RageBot.EnableHitbox(ent, 4, state)
        RageBot.EnableMultipoints(ent, 4, state)
        RageBot.EnableHitbox(ent, 5, state)
        RageBot.EnableMultipoints(ent, 5, state)
        RageBot.EnableHitbox(ent, 6, state)
        RageBot.EnableMultipoints(ent, 6, state)
    end
        
    forcebaim_lethal.RageBot_legs = function(ent, state)
        RageBot.EnableHitbox(ent, 7, state)
        RageBot.EnableMultipoints(ent, 7, state)
        RageBot.EnableHitbox(ent, 8, state)
        RageBot.EnableMultipoints(ent, 8, state)
        RageBot.EnableHitbox(ent, 9, state)
        RageBot.EnableMultipoints(ent, 9, state)
        RageBot.EnableHitbox(ent, 10, state)
        RageBot.EnableMultipoints(ent, 10, state)
        RageBot.EnableHitbox(ent, 11, state)
        RageBot.EnableMultipoints(ent, 11, state)
        RageBot.EnableHitbox(ent, 12, state)
        RageBot.EnableMultipoints(ent, 12, state)
    end

    forcebaim_lethal.RageBot_arms = function(ent, state)
        RageBot.EnableHitbox(ent, 13, state)
        RageBot.EnableMultipoints(ent, 13, state)
        RageBot.EnableHitbox(ent, 14, state)
        RageBot.EnableMultipoints(ent, 14, state)
        RageBot.EnableHitbox(ent, 15, state)
        RageBot.EnableMultipoints(ent, 15, state)
        RageBot.EnableHitbox(ent, 16, state)
        RageBot.EnableMultipoints(ent, 16, state)
        RageBot.EnableHitbox(ent, 17, state)
        RageBot.EnableMultipoints(ent, 17, state)
        RageBot.EnableHitbox(ent, 18, state)
        RageBot.EnableMultipoints(ent, 18, state)
    end

    forcebaim_lethal.on_prediction = function()

        if not global_bool:Get() or not Tab["Global"].forcebaimonlethal_bool.var:Get() then
            return
        end

        local localplayer = isvalidlp()

        if localplayer == nil then 
            return 
        end

        for _, Enemy in pairs(GetEnemies()) do
            
            if Enemy == nil then
                return
            end

            local weap = localplayer:GetActiveWeapon()

            if weap == nil then
                return
            end

            weap = weap:GetWeaponDamage()

            if Enemy:GetProp("DT_BasePlayer", "m_iHealth") < weap then
                forcebaim_lethal.RageBot_baim(Enemy:EntIndex(), true)
                forcebaim_lethal.RageBot_head(Enemy:EntIndex(), false)
                forcebaim_lethal.RageBot_legs(Enemy:EntIndex(), false)
                forcebaim_lethal.RageBot_arms(Enemy:EntIndex(), false)
            end
        end
    end

-- @end_region = Force Baim If Lethal

-- @region = Watermark / Keybinds / Spectators List Modern

    local solus = {}

    Tab["Visuals"].widgets_mcombo = {var = Menu.MultiCombo("Visuals", "Visuals", "Widgets", {"Watermark", "Keybinds", "Spectators"}, 0, ""), color = false}

    Tab["Visuals"].solus_username_combo = {var = Menu.Combo("Visuals", "Visuals", "Username Type",{"Cheat Username", "In-game", "Custom Name"}, 0), color = false}
    Tab["Visuals"].solus_cheatname_combo = {var = Menu.Combo("Visuals", "Visuals", "Cheat Name",{"Valency", "Gamesense", "Neverlose"}, 0), color = false}
    Tab["Visuals"].solus_style_combo = {var = Menu.Combo("Visuals", "Visuals", "Solus Style",{"Style 1", "Style 2", "Style 3"}, 0), color = false}
    Tab["Visuals"].solus_customusername = {var = Menu.TextBox("Visuals", "Visuals", "Custom name", 50, player_name.cheat), color = false}
    Tab["Visuals"].solus_color = {var = Menu.ColorEdit("Visuals", "Visuals", "Solus Color", Color.RGBA(114, 120, 181, 255)), color = true}


    WatermarkName = function(mode, custom)
        if mode == 0 then return player_name.cheat .. '   '
        elseif mode == 1 then 
            return player_name.steam .. '   '
        elseif mode == 2 then 
            if custom == '' then
                return ''
            else 
                return custom .. '   '
            end
        end
    end

    Render_Text = function(x, y, cent, text, color, font, size, alpha)
        Render.Text(text,Vector2.new(x + 1, y + 1), Color.RGBA(0, 0, 0, alpha), size, font, false, cent)
        Render.Text(text,Vector2.new(x, y), color, size, font, false, cent)
    end

    ping = function()
        local netchannel_info = EngineClient.GetNetChannelInfo()
        if netchannel_info == nil then return '' end
        local latency = netchannel_info:GetLatency(0)
        return string.format("delay: %1.fms   ", math.max(0, latency) * 1000)
    end

    RenderGradientBox = function(x,y,w,h1,h2,c,alpha,transp)
    
        color1 = Color.RGBA(math.floor(c.r*255), math.floor(c.g*255), math.floor(c.b*255), math.floor(alpha))
        color2 = Color.RGBA(math.floor(c.r*255), math.floor(c.g*255), math.floor(c.b*255), math.floor(alpha/10))
        color3 = Color.RGBA(math.floor(c.r*255), math.floor(c.g*255), math.floor(c.b*255), math.floor(alpha*0.35))

        if Tab["Visuals"].solus_style_combo.var:Get() == 1 then
            -- background
            Render.BoxFilled(Vector2.new(x, y), Vector2.new(x + w, y + h1 + 1), Color.RGBA(17, 17, 17, math.floor(transp)), 4)
            -- down
            Render.BoxFilled(Vector2.new(x+3,y+h1+1),Vector2.new(x + w - 3 , y + h1 + 3),Color.RGBA(math.floor(c.r*255),math.floor(c.g*255),math.floor(c.b*255),math.floor(alpha*0.35)))
            -- left down
            Render.Circle(Vector2.new(x + 3,y+h1-2), 4, 32, color3, 2, 90, 180)
            -- right down
            Render.Circle(Vector2.new(x + w - 3, y + h1 - 2), 4, 32, color3, 2, 0, 90)
        end
        
        if Tab["Visuals"].solus_style_combo.var:Get() == 0 then
            -- background
            Render.BoxFilled(Vector2.new(x, y), Vector2.new(x + w, y + h1), Color.RGBA(17, 17, 17, math.floor(transp)), 4)
        end

        if Tab["Visuals"].solus_style_combo.var:Get() == 0 or Tab["Visuals"].solus_style_combo.var:Get() == 1 then
            -- left up
            Render.Circle(Vector2.new(x + 3 , y + 5), 4, 32, color1, 2, 270, 180)
            Render.GradientBoxFilled(Vector2.new(x - 2 , y + 5), Vector2.new(x, y + h1 -2 ), color1, color1, color2, color2)
            -- right up 
            Render.Circle(Vector2.new(x + w - 3, y + 5), 4, 32, color1, 2, 0, -90)
            Render.GradientBoxFilled(Vector2.new(x + w, y + 5), Vector2.new(x + w + 2, y + h1 - 2), color1, color1, color2, color2)

            -- up
            Render.BoxFilled(Vector2.new(x + 3, y), Vector2.new(x + w - 3, y + h2), Color.RGBA(math.floor(c.r*255), math.floor(c.g*255), math.floor(c.b*255), math.floor(alpha)))

            -- corner   
            Render.BoxFilled(Vector2.new(x - 1, y + 2), Vector2.new(x + 1 + w, y + h2), Color.RGBA(math.floor(c.r*255), math.floor(c.g*255), math.floor(c.b*255), math.floor(alpha)))
        end

        if Tab["Visuals"].solus_style_combo.var:Get()==2 then
            -- glow
            for i = 1, 5 do
                local glow_value = 1/i
                glow_value = glow_value + 1

                --right
                Render.BoxFilled(Vector2.new(x + w - 1 * i, y + 1 * i), Vector2.new(x + w + 1 * i, y + h1 - 1 * i), Color.new(color1.r, color1.g, color1.b, glow_value / 80 * color1.a)) 
                -- left
                Render.BoxFilled(Vector2.new(x - 1 * i, y + 1 * i), Vector2.new(x + 1 * i, y + h1 - 1 * i), Color.new(color1.r, color1.g, color1.b, glow_value / 80 * color1.a))
                -- top
                Render.BoxFilled(Vector2.new(x - 1 * i, y - 1 * i), Vector2.new(x + w + 1 * i, y + 1 * i), Color.new(color1.r, color1.g, color1.b, glow_value / 80 * color1.a), 10)
                -- bottom
                Render.BoxFilled(Vector2.new(x - 1 * i, y + h1 - 1 * i), Vector2.new(x + w + 1 * i, y + h1 + 1 * i), Color.new(color1.r, color1.g, color1.b, glow_value / 80 * color1.a), 10)
            end

            -- background
            Render.Blur(Vector2.new(x+1, y+0.4), Vector2.new(x-1 + w, y + h1 - 0.4), Color.RGBA((255 - math.floor(c.a*255)), (255 - math.floor(c.a*255)), (255 - math.floor(c.a*255)), math.floor(alpha)))

            
            -- left
            Render.GradientBoxFilled(Vector2.new(x , y + 4), Vector2.new(x + 1, y + h1 - 2), color1, color1, color2, color2)
            Render.Circle(Vector2.new(x + 4 , y + 4), 4, 32, color1, 1, 270, 180)
            Render.Circle(Vector2.new(x + 4 , y + h1 - 3), 4, 32, color2, 1, 180, 90)


            -- right
            Render.GradientBoxFilled(Vector2.new(x + w, y + 4), Vector2.new(x + w -1, y + h1 - 3), color1, color1, color2, color2)
            Render.Circle(Vector2.new(x + w - 4, y + 4), 4, 32, color1, 1, 0, -90)
            Render.Circle(Vector2.new(x + w - 4, y + h1 - 3), 4, 32, color2, 1, 0, 90)


            -- up
            Render.BoxFilled(Vector2.new(x + 4, y), Vector2.new(x + w - 4, y + 1), color1)

            -- down
            Render.BoxFilled(Vector2.new(x + 4, y + h1 +1), Vector2.new(x + w - 4, y + h1), color2)
        end
    end

    local  bind_type = {
        [0] = 'toggled',
        [1] = 'holding',
    }

    local alpha = {
        k = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        o = 66,
        water = 0.0,
        global = 0.0,
        xxx = 0.0,
    }

    solus.memory_spec, solus.memory = Vector2.new(0, 0), Vector2.new(0, 0)
    local IsDragging, IsDragging_spec = 0, 0
    local local_time = ffi.new("SYSTEMTIME")

    solus.x_key = Menu.SliderInt("Visuals", "Visuals", "keybinds x", 150, 0, engine_client.screen_size.x) vis(solus.x_key, false)
    solus.y_key = Menu.SliderInt("Visuals", "Keybinds", "keybinds y", 500, 0, engine_client.screen_size.y) vis(solus.y_key, false)
    solus.x_spec = Menu.SliderInt("Visuals", "Visuals", "spec x", 1450, 0, engine_client.screen_size.x) vis(solus.x_spec, false)
    solus.y_spec = Menu.SliderInt("Visuals", "Keybinds", "spec y", 500, 0, engine_client.screen_size.y) vis(solus.y_spec, false)

    solus.watermark = function()

        if not visuals_bool:Get() or not Tab["Visuals"].widgets_mcombo.var:Get(1) then
            return
        end

        ffi.C.GetLocalTime(local_time)
        system_time = string.format("%02d:%02d:%02d", local_time.wHour, local_time.wMinute, local_time.wSecond)

        local x_WM, y_WM = engine_client.screen_size.x, 10

        local secondStrCol = Color.new(Tab["Visuals"].solus_color.var:Get().r, Tab["Visuals"].solus_color.var:Get().g, Tab["Visuals"].solus_color.var:Get().b, 1)

        if Tab["Visuals"].solus_cheatname_combo.var:Get() == 0 then

            firstStr_WM = "vale"
            secondStr_WM = "ncy"
            text_WM = ''..firstStr_WM..'         ' .. '' .. WatermarkName(Tab["Visuals"].solus_username_combo.var:Get(), Tab["Visuals"].solus_customusername.var:Get()) .. '' .. ping() .. '' .. system_time
        
        elseif Tab["Visuals"].solus_cheatname_combo.var:Get() == 1 then

            firstStr_WM = "game"
            secondStr_WM = "sense"
            text_WM = ''..firstStr_WM..'             ' .. '' .. WatermarkName(Tab["Visuals"].solus_username_combo.var:Get(), Tab["Visuals"].solus_customusername.var:Get()) .. '' .. ping() .. '' .. system_time

        elseif Tab["Visuals"].solus_cheatname_combo.var:Get() == 2 then

            firstStr_WM = "never"
            secondStr_WM = "lose"
            text_WM = ''..firstStr_WM..'          ' .. '' .. WatermarkName(Tab["Visuals"].solus_username_combo.var:Get(), Tab["Visuals"].solus_customusername.var:Get()) .. '' .. ping() .. '' .. system_time

        end

        local h_WM, w_WM = 18, Render.CalcTextSize(text_WM, 11, font.verdana11r).x + 8

        x_WM = x_WM - w_WM - 10

        RenderGradientBox(x_WM, y_WM, w_WM, h_WM, 2, Tab["Visuals"].solus_color.var:Get(), 255, Tab["Visuals"].solus_color.var:Get().a*255)
        Render_Text(x_WM + 4, Tab["Visuals"].solus_style_combo.var:Get()==2 and y_WM + 3 or y_WM + 4, false, text_WM, Color.RGBA(255, 255, 255, 255), font.verdana11r, 11, 120)
        Render_Text(x_WM + 4 + Render.CalcTextSize(firstStr_WM, 11, font.verdana11r).x + 0.9, Tab["Visuals"].solus_style_combo.var:Get()==2 and y_WM + 2.999999999 or y_WM + 3.999999999, false, secondStr_WM , secondStrCol, font.verdana11r, 11, 120)
    end

    solus.keybinds = function()

        if not visuals_bool:Get() or not Tab["Visuals"].widgets_mcombo.var:Get(2) then
            return
        end

        local frames = 8 * GlobalVars.frametime
        local max_offset = 66
        local hOffset = 23
        local w, h = 75 + max_offset, 50

        local to = math.max(66, alpha.o)

        
        if solus.x_key:Get() < 0 then
            solus.x_key:Set(0)
        end
        if solus.x_key:Get() > engine_client.screen_size.x - (75 + to) then
            solus.x_key:Set(engine_client.screen_size.x - (75 + to))
        end

        if solus.y_key:Get() < 0 then
            solus.y_key:Set(0)
        end
        if solus.y_key:Get() > engine_client.screen_size.y - 18 then
            solus.y_key:Set(engine_client.screen_size.y - 18)
        end

        local binds = Cheat.GetBinds()
        for i = 0, #binds do
            alpha.global = add_animation(#binds > 0 and Tab["Visuals"].widgets_mcombo.var:Get(2) or Cheat.IsMenuVisible() and Tab["Visuals"].widgets_mcombo.var:Get(2) , alpha.global, 0, 1, frames)
        end
        
        for f = 1, #binds do
            local key_type = '[' .. bind_type[binds[f]:GetMode()] .. ']'
            alpha.k[f] = add_animation(binds[f]:IsActive() == true and alpha.global > 0 and Tab["Visuals"].widgets_mcombo.var:Get(2), alpha.k[f], 0, 1, frames)             
            local bind_width = Render.CalcTextSize(binds[f]:GetName(),11,font.verdana11r).x
            if bind_width > 0 then
                if bind_width > 75 then
                    max_offset = bind_width
                end
            end

            Render_Text(solus.x_key:Get() + 5, solus.y_key:Get() + hOffset, false, binds[f]:GetName(), Color.RGBA(255, 255, 255, math.floor(alpha.k[f]*255)), font.verdana11r, 11, math.floor(alpha.k[f]*120))
            Render_Text(solus.x_key:Get() + (75 + alpha.o) - Render.CalcTextSize(key_type, 11, font.verdana11r).x - 5, solus.y_key:Get() + hOffset, false, key_type, Color.RGBA(255, 255, 255, math.floor(alpha.k[f]*255)), font.verdana11r, 11, math.floor(alpha.k[f]*120))
            hOffset = hOffset + 15
            
        end

        if alpha.o ~= max_offset then
            if alpha.o > max_offset then alpha.o = alpha.o - 1.2 end
            if alpha.o < max_offset then alpha.o = alpha.o + 1.2 end
        end

        RenderGradientBox(solus.x_key:Get(), solus.y_key:Get(), (75 + to), 18, 2, Tab["Visuals"].solus_color.var:Get(), math.floor(alpha.global*255), (alpha.global*Tab["Visuals"].solus_color.var:Get().a*255))
        Render_Text(solus.x_key:Get() - Render.CalcTextSize("keybinds", 11, font.verdana11r).x / 2 + (75 + to) / 2, Tab["Visuals"].solus_style_combo.var:Get()==2 and solus.y_key:Get()+ 3 or solus.y_key:Get()+ 4, false, "keybinds", Color.RGBA(255, 255, 255, math.floor(alpha.global*255)), font.verdana11r, 11, math.floor(alpha.global*120))

        if Cheat.GetMousePos().x >= solus.x_key:Get() and Cheat.GetMousePos().x <= solus.x_key:Get() + 75 + to and Cheat.GetMousePos().y >= solus.y_key:Get() and Cheat.GetMousePos().y <= solus.y_key:Get() + 20 then
            if Cheat.IsKeyDown(1) and IsDragging == 0 and Cheat.GetMousePos().x < solus.x_key:Get() + 75 + to and Cheat.GetMousePos().y < solus.y_key:Get() + 20 then

                if IsDragging_spec == 1 then
                    return
                end 

                IsDragging = 1;
                solus.memory.x = solus.x_key:Get() - Cheat.GetMousePos().x
                solus.memory.y = solus.y_key:Get() - Cheat.GetMousePos().y
            end
        end

        if not Cheat.IsKeyDown(1) then
            IsDragging = 0
        end
        
        if IsDragging == 1 and Cheat.IsMenuVisible() then
            solus.x_key:Set(Cheat.GetMousePos().x + solus.memory.x)
            solus.y_key:Set(Cheat.GetMousePos().y + solus.memory.y)
        end
    end

    solus.spectators = function()

        if not visuals_bool:Get() or not Tab["Visuals"].widgets_mcombo.var:Get(3) then
            return
        end

        local spectators = {}

        local players = EntityList.GetPlayers()
        if not players then 
            return 
        end
        
        local me = EntityList.GetLocalPlayer()

        local frames = 8 * GlobalVars.frametime
        local xx = 141

        if solus.x_spec:Get() < 0 then
            solus.x_spec:Set(0)
        end
        if solus.x_spec:Get() > engine_client.screen_size.x - xx then
            solus.x_spec:Set(engine_client.screen_size.x - xx)
        end

        if solus.y_spec:Get() < 0 then
            solus.y_spec:Set(0)
        end
        if solus.y_spec:Get() > engine_client.screen_size.y - 18 then
            solus.y_spec:Set(engine_client.screen_size.y - 18)
        end
        
        for _, player in pairs(players) do
            if not player:IsDormant() and player:GetProp("m_iHealth") < 1 then
                local target = EntityList.GetPlayerFromHandle(player:GetProp("m_hObserverTarget"))
                local player_name = player:GetName()
                 
                if #player_name > 23 then
                    player_name = string.format("%s...", player_name:sub(0, 23))
                end

                if target == me then
                    spectators[#spectators + 1] = { name = player_name }
                end
            end
        end

        for i = 0, #spectators do 
            alpha.xxx = add_animation(#spectators > 0 or Cheat.IsMenuVisible(), alpha.xxx, 0, 1, frames)

            if spectators[i] ~= nil then 

                Render_Text(solus.x_spec:Get() + 5, solus.y_spec:Get() + 7 + 15 * i, false, spectators[i].name, Color.RGBA(255,255,255,255), font.verdana11r, 11, 120)

            end
        end

        RenderGradientBox(solus.x_spec:Get(), solus.y_spec:Get(), xx, 18, 2, Tab["Visuals"].solus_color.var:Get(), math.floor(alpha.xxx*255), alpha.xxx*Tab["Visuals"].solus_color.var:Get().a*255)

        Render_Text(solus.x_spec:Get() - Render.CalcTextSize("spectators", 11, font.verdana11r).x / 2 + xx / 2, Tab["Visuals"].solus_style_combo.var:Get()==2 and solus.y_spec:Get() + 3 or solus.y_spec:Get() + 4, false, "spectators", Color.RGBA(255, 255, 255, math.floor(alpha.xxx*255)), font.verdana11r, 11, math.floor(alpha.xxx*120))

        if Cheat.GetMousePos().x >= solus.x_spec:Get() and Cheat.GetMousePos().x <= solus.x_spec:Get() + xx and Cheat.GetMousePos().y >= solus.y_spec:Get() and Cheat.GetMousePos().y <= solus.y_spec:Get() + 20 then
            if Cheat.IsKeyDown(1) and IsDragging_spec == 0 and Cheat.GetMousePos().x < solus.x_spec:Get() + xx and Cheat.GetMousePos().y < solus.y_spec:Get() + 20 then

                if IsDragging == 1 then
                    return
                end 

                IsDragging_spec = 1;
                solus.memory_spec.x = solus.x_spec:Get() - Cheat.GetMousePos().x
                solus.memory_spec.y = solus.y_spec:Get() - Cheat.GetMousePos().y
            end
        end

        if not Cheat.IsKeyDown(1) then
            IsDragging_spec = 0
        end
        
        if IsDragging_spec == 1 and Cheat.IsMenuVisible() then
            solus.x_spec:Set(Cheat.GetMousePos().x + solus.memory_spec.x)
            solus.y_spec:Set(Cheat.GetMousePos().y + solus.memory_spec.y)
        end
    end

-- @end_region = Watermark / Keybinds / Spectators List Modern


-- @region = Indicators Alternative

    local indicators = {}

    Tab["Visuals"].indic_bool = {var = Menu.Switch("Visuals", "Visuals", "Indicators", false, "This will render lua styled indicators on the middle of the screen containing some usefull info."), color = false}
    Tab["Visuals"].indic_mcombo = {var = Menu.MultiCombo("Visuals", "Visuals", "Indicators Options", {"Desync", "Bind State"}, 0, ""), color = false}
    Tab["Visuals"].indic_logoCol = {var = Menu.ColorEdit("Visuals", "Visuals", "Logo Color", Color.RGBA(255, 255, 255)), color = true}
    Tab["Visuals"].indic_desyncCol = {var = Menu.ColorEdit("Visuals", "Visuals", "Logo Desync Color", Color.RGBA(255, 255, 255)), color = true}
    Tab["Visuals"].indic_lineCol = {var = Menu.ColorEdit("Visuals", "Visuals", "Desync Bar Color", Color.RGBA(255, 255, 255)), color = true}


    desync_delta = function()
        local eye_angle = EntityList.GetLocalPlayer():GetProp("m_angEyeAngles[1]")
        local real_rotation = AntiAim.GetCurrentRealRotation()
        local min_delta = AntiAim.GetMinDesyncDelta()
        local max_delta = AntiAim.GetMaxDesyncDelta()
        return math.abs(math_round(math_clamp(math_normalize(real_rotation - eye_angle), min_delta, max_delta)))
    end

    indicators.alpha = {
        misc = 0.0,
        modifier_vel = 0.0,
        dt = 0.0,
        hs = 0.0,
        dmg = 0.0,
    }


    indicators.add = {
        x = 0,
        y = 0,
        x_dt_hs = 0,
        x_valency_anim = 0.0,
        x_customtxt_anim = 0.0,
        x_veloc_anim = 0.0,
        x_dtexp_anim = 0.0,
        x_hsexp_anim = 0.0,
        x_dmgexp_anim = 0.0,
    }


    indicators.draw = function()

        if not Tab["Visuals"].indic_bool.var:Get() or not visuals_bool:Get() then
            return
        end 

        local localplayer = isvalidlp()

        if localplayer == nil then 
            return 
        end
        
        local indic_text = ""
        local delta_angle = desync_delta()
        local delta_angle_text = string.format("%.0f", delta_angle)

        local line_color = Tab["Visuals"].indic_lineCol.var:GetColor()
        local modifier_vel = localplayer:GetProp('m_flVelocityModifier') + 0.01
        local alpha_frames = 8 * GlobalVars.frametime
        local anim_frames = 700 * GlobalVars.frametime
        local scoped = EntityList.GetLocalPlayer():GetProp("m_bIsScoped")
        local alt_active = not Cheat.IsKeyDown(0x09) and Tab["Visuals"].indic_bool.var:Get() and visuals_bool:Get()


        if Cheat.IsKeyDown(0x45) == true then
            indic_text = "LEGIT AA"   
        elseif aa[0].manual:Get() ~= 0 then
            indic_text = "MANUAL AA" 
        else
            indic_text = "VALENCY YAW"
        end
            
            indicators.add.y = new_animation("addy_alt_indic", alt_active and 30 or 0, false)

            indicators.add.x_valency_anim = add_animation(scoped, indicators.add.x_valency_anim, 0, 60, anim_frames)
            indicators.alpha.misc = new_animation("alt_indic_misc_alpha", alt_active and 1 or 0, false)

            if indic_text == "MANUAL AA" then
                indicators.add.x_customtxt_anim = add_animation(scoped , indicators.add.x_customtxt_anim, 0, 55, anim_frames)
            elseif indic_text == "LEGIT AA" then
                indicators.add.x_customtxt_anim = add_animation(scoped, indicators.add.x_customtxt_anim, 0, 46, anim_frames)
            end
            
            if Tab["Visuals"].indic_mcombo.var:Get(1) then

                Render.Text(delta_angle_text, engine_client.screen_center + Vector2.new(indicators.add.x + indicators.add.x_valency_anim, indicators.add.y) + 1, Color.new(0, 0, 0, indicators.alpha.misc), 12, font.verdana12, false, true)
                Render.Text(delta_angle_text, engine_client.screen_center + Vector2.new(indicators.add.x + indicators.add.x_valency_anim, indicators.add.y), Color.new(1, 1, 1, indicators.alpha.misc), 12, font.verdana12, false, true)

                indicators.add.y = indicators.add.y + 10

                Render.GradientBoxFilled(engine_client.screen_center - Vector2.new(-delta_angle - indicators.add.x_valency_anim, 1 - indicators.add.y), engine_client.screen_center + Vector2.new(indicators.add.x + indicators.add.x_valency_anim, indicators.add.y), Color.new(line_color.r, line_color.g, line_color.b, 0), Color.new(line_color.r, line_color.g, line_color.b, line_color.a * indicators.alpha.misc), Color.new(line_color.r, line_color.g, line_color.b, 0), Color.new(line_color.r, line_color.g, line_color.b, line_color.a * indicators.alpha.misc))
                Render.GradientBoxFilled(engine_client.screen_center - Vector2.new(delta_angle - indicators.add.x_valency_anim, 1 - indicators.add.y), engine_client.screen_center + Vector2.new(indicators.add.x + indicators.add.x_valency_anim, indicators.add.y), Color.new(line_color.r, line_color.g, line_color.b, 0), Color.new(line_color.r, line_color.g, line_color.b, line_color.a * indicators.alpha.misc), Color.new(line_color.r, line_color.g, line_color.b, 0), Color.new(line_color.r, line_color.g, line_color.b, line_color.a * indicators.alpha.misc))
                
                indicators.add.y = indicators.add.y + 10

            end

        if indic_text == "VALENCY YAW" then

            local active_color = Tab["Visuals"].indic_desyncCol.var:GetColor()
            local non_active_color = Tab["Visuals"].indic_logoCol.var:GetColor()

            local logo_color = new_animation("logo_color", AntiAim.GetInverterState() and active_color or non_active_color, true)
            local desync_color = new_animation("desync_color", AntiAim.GetInverterState() and non_active_color or active_color, true)
            
            local valency_size = Render.CalcTextSize("VALENCY YAW", 12, font.verdana12) / 2

            Render.Text("VALENCY", engine_client.screen_center + 1 - Vector2.new(valency_size.x - indicators.add.x_valency_anim, 0) + Vector2.new(indicators.add.x, indicators.add.y - valency_size.y), Color.new(0, 0, 0, indicators.alpha.misc * logo_color.a), 12, font.verdana12)
            Render.Text("VALENCY", engine_client.screen_center - Vector2.new(valency_size.x - indicators.add.x_valency_anim, 0) + Vector2.new(indicators.add.x, indicators.add.y - valency_size.y), Color.new(logo_color.r, logo_color.g, logo_color.b, indicators.alpha.misc * logo_color.a), 12, font.verdana12)
            Render.Text("YAW", engine_client.screen_center + 1 + Vector2.new(valency_size.x / 3 + indicators.add.x_valency_anim, 0) + Vector2.new(indicators.add.x, indicators.add.y - valency_size.y), Color.new(0, 0, 0, indicators.alpha.misc * desync_color.a), 12, font.verdana12)
            Render.Text("YAW", engine_client.screen_center + Vector2.new(valency_size.x / 3 + indicators.add.x_valency_anim, 0) + Vector2.new(indicators.add.x, indicators.add.y - valency_size.y), Color.new(desync_color.r, desync_color.g, desync_color.b, indicators.alpha.misc * desync_color.a), 12, font.verdana12)
        else
            Render.Text(indic_text, engine_client.screen_center + Vector2.new(indicators.add.x + indicators.add.x_customtxt_anim, indicators.add.y) + 1, Color.new(0, 0, 0, indicators.alpha.misc), 12, font.verdana12, false, true)
            Render.Text(indic_text, engine_client.screen_center + Vector2.new(indicators.add.x + indicators.add.x_customtxt_anim, indicators.add.y), Color.new(1, 1, 1, indicators.alpha.misc), 12, font.verdana12, false, true)
        end

            indicators.alpha.modifier_vel = add_animation((modifier_vel < 1) and alt_active, indicators.alpha.modifier_vel, 0, 1, alpha_frames)
            indicators.add.x_veloc_anim = add_animation(scoped, indicators.add.x_veloc_anim, 0, 54, anim_frames)
            
        if indicators.alpha.modifier_vel ~= 0 then
            indicators.add.y = indicators.add.y + 8

            Render.BoxFilled(Vector2.new(engine_client.screen_center.x + indicators.add.x_veloc_anim - 30, engine_client.screen_center.y + indicators.add.y) - 1, Vector2.new(engine_client.screen_center.x + indicators.add.x_veloc_anim - 30 + 60, engine_client.screen_center.y + indicators.add.y + 1) + 1, Color.new(0, 0, 0, indicators.alpha.modifier_vel))
            Render.BoxFilled(Vector2.new(engine_client.screen_center.x + indicators.add.x_veloc_anim - 30, engine_client.screen_center.y + indicators.add.y), Vector2.new(engine_client.screen_center.x + indicators.add.x_veloc_anim - 30 + 60, engine_client.screen_center.y + indicators.add.y + 1) - Vector2.new(60 - (60 * modifier_vel), 0), Color.new(1, 1, 1, indicators.alpha.modifier_vel))
        end

        indicators.add.y = indicators.add.y + 12

        -- exploits

        -- alphas

        if not Tab["Visuals"].indic_mcombo.var:Get(2) then
            return
        end

        indicators.alpha.dt = new_animation("alt_indic_dt_alpha", (references.doubletap:Get() and alt_active) and 1 or 0, false)
        indicators.alpha.hs = new_animation("alt_indic_hs_alpha", (references.hideshot:Get() and not references.doubletap:Get() and alt_active) and 1 or 0, false)
        indicators.alpha.dmg = new_animation("alt_indic_dmg_alpha", (bind_get("Minimum Damage", true) and alt_active) and 1 or 0, false)

        if references.hideshot:Get() then
            dt_text = "DT "
            indicators.add.x_dt_hs = 3.5
        else
            dt_text = "DT"
            indicators.add.x_dt_hs = 0
        end    
        
        if references.doubletap:Get() then
            local exploit_charge = Exploits.GetCharge()
            angle_circle_dt = (exploit_charge * 360)
        else
            angle_circle_dt = (indicators.alpha.dt * 360)
        end
        --

        indicators.add.x_dtexp_anim = add_animation(scoped, indicators.add.x_dtexp_anim, 0, 42, anim_frames)
        indicators.add.x_hsexp_anim = add_animation(scoped, indicators.add.x_hsexp_anim, 0, 48, anim_frames)
        indicators.add.x_dmgexp_anim = add_animation(scoped, indicators.add.x_dmgexp_anim, 0, 34.5, anim_frames)

        if indicators.alpha.dt > 0 then
            local exploit_charge = Exploits.GetCharge()
            local text_size = Render.CalcTextSize("DT", 12, font.verdana12).x

            Render.Circle(engine_client.screen_center + Vector2.new(-text_size + indicators.add.x_dtexp_anim, indicators.add.y), 4.0, 10, Color.new(1 - exploit_charge, exploit_charge, 0, indicators.alpha.dt), 1.5, 0, angle_circle_dt / 1)
            Render.Text(dt_text, engine_client.screen_center + Vector2.new(indicators.add.x_dt_hs + indicators.add.x_dtexp_anim, indicators.add.y) + 1, Color.new(0, 0, 0, indicators.alpha.dt), (text_size - 2), font.verdana12, false, true)
            Render.Text(dt_text, engine_client.screen_center + Vector2.new(indicators.add.x_dt_hs + indicators.add.x_dtexp_anim, indicators.add.y), Color.new(1 - exploit_charge, exploit_charge, 0, indicators.alpha.dt), (text_size - 2), font.verdana12, false, true)
            indicators.add.y = indicators.add.y + 12 * indicators.alpha.dt
        end

        if indicators.alpha.hs ~= 0 then
            local exploit_charge = Exploits.GetCharge()

            Render.Text("ON-SHOT", engine_client.screen_center + Vector2.new(indicators.add.x + indicators.add.x_hsexp_anim, indicators.add.y) + 1, Color.new(0, 0, 0, indicators.alpha.hs), 12, font.verdana12, false, true)
            Render.Text("ON-SHOT", engine_client.screen_center + Vector2.new(indicators.add.x + indicators.add.x_hsexp_anim, indicators.add.y), Color.new(1 - exploit_charge, exploit_charge, 0, indicators.alpha.hs), 12, font.verdana12, false, true)
            indicators.add.y = indicators.add.y + 12 * indicators.alpha.hs
        end

        -- min dmg
        if indicators.alpha.dmg > 0 then
            Render.Text("DMG", engine_client.screen_center + Vector2.new(indicators.add.x + indicators.add.x_dmgexp_anim, indicators.add.y) + 1, Color.new(0, 0, 0, indicators.alpha.dmg), 12, font.verdana12, false, true)
            Render.Text("DMG", engine_client.screen_center + Vector2.new(indicators.add.x + indicators.add.x_dmgexp_anim, indicators.add.y), Color.new(0, 1, 0, indicators.alpha.dmg), 12, font.verdana12, false, true)
        end	
    end

-- @end_region = Indicators Alternative


-- @region = Arrows Indicator

    render_text = function(text, pos, color, size, text_font, outline, align)
        local text_size = Render.CalcTextSize(text, size, text_font)
        
        if align == 0 then
            Render.Text(text, Vector2.new(pos.x - text_size.x, pos.y), color, size, text_font, outline)
        elseif align == 1 then
            Render.Text(text, Vector2.new(pos.x - (text_size.x / 2), pos.y), color, size, text_font, outline)
        elseif align == 2 then
            Render.Text(text, pos, color, size, text_font, outline)
        end
    end 


    Tab["Visuals"].arows_combo = {
        var = Menu.Combo("Visuals", "Visuals", "Manual Arrows", { "Off","Default", "Alternative"}, 0 , "This will render manual arrows on the middle of the screen containing yaw info."), 
        color = false
    }
    Tab["Visuals"].arrows_mainCol = {
        var = Menu.ColorEdit("Visuals", "Visuals", "Arrow Color", Color.new(1, 1, 1, 1), "Main Line Color"), 
        color = true
    }
    Tab["Visuals"].arrows_manuaCol = {
        var = Menu.ColorEdit("Visuals", "Visuals", "Manual Yaw Arrow color", Color.new(1, 1, 1, 1), "Manual Yaw Base Arrows Color"), 
        color = true
    }

    indicatorarrows = function()

        if not visuals_bool:Get() and Tab["Visuals"].arows_combo.var:Get() ~= 0 then
            return
        end

        local localplayer = isvalidlp()

        if localplayer == nil then 
            return 
        end

        if Cheat.IsKeyDown(0x09) then 
            return 
        end

        local main_color = Tab["Visuals"].arrows_mainCol.var:GetColor()
        local normal_arrows_size = 20
        local inverted = AntiAim.GetInverterState()
        local manual_color = Tab["Visuals"].arrows_manuaCol.var:GetColor()
            
        if Tab["Visuals"].arows_combo.var:Get() == 1 then
            if inverted then

                render_text("<", Vector2.new(engine_client.screen_center.x - 50, engine_client.screen_center.y - 11), Color.new(0, 0, 0, 0.3), normal_arrows_size, font.verdana40r, false, 1)

                render_text(">", Vector2.new(engine_client.screen_center.x + 50, engine_client.screen_center.y - 11), main_color, normal_arrows_size, font.verdana40r, false, 1)
                    
            elseif not inverted then
                
                render_text("<", Vector2.new(engine_client.screen_center.x - 50, engine_client.screen_center.y - 11), main_color, normal_arrows_size, font.verdana40r, false, 1)

                render_text(">", Vector2.new(engine_client.screen_center.x + 50, engine_client.screen_center.y - 11), Color.new(0, 0, 0, 0.3), normal_arrows_size, font.verdana40r, false, 1)
            end
        end

        if Tab["Visuals"].arows_combo.var:Get() == 2 then
            if inverted then

                
                Render.PolyFilled(Color.new(0, 0, 0, 0.3), Vector2.new(engine_client.screen_center.x - 57, engine_client.screen_center.y), Vector2.new(engine_client.screen_center.x - 42, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x - 42, engine_client.screen_center.y + 9))
                Render.PolyFilled(Color.new(0, 0, 0, 0.3), Vector2.new(engine_client.screen_center.x - 40, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x - 38 , engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x - 38, engine_client.screen_center.y + 9), Vector2.new(engine_client.screen_center.x - 40, engine_client.screen_center.y + 9))
                    

                Render.PolyFilled(Color.new(0, 0, 0, 0.3), Vector2.new(engine_client.screen_center.x + 57, engine_client.screen_center.y), Vector2.new(engine_client.screen_center.x + 42, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x + 42, engine_client.screen_center.y + 9))
                Render.PolyFilled(main_color, Vector2.new(engine_client.screen_center.x + 40, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x + 38 , engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x + 38, engine_client.screen_center.y + 9), Vector2.new(engine_client.screen_center.x + 40, engine_client.screen_center.y + 9))
                    
            elseif not inverted then

                Render.PolyFilled(Color.new(0, 0, 0, 0.3), Vector2.new(engine_client.screen_center.x - 57, engine_client.screen_center.y), Vector2.new(engine_client.screen_center.x - 42, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x - 42, engine_client.screen_center.y + 9))
                Render.PolyFilled(main_color, Vector2.new(engine_client.screen_center.x - 40, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x - 38 , engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x - 38, engine_client.screen_center.y + 9), Vector2.new(engine_client.screen_center.x - 40, engine_client.screen_center.y + 9))
                    

                Render.PolyFilled(Color.new(0, 0, 0, 0.3), Vector2.new(engine_client.screen_center.x + 57, engine_client.screen_center.y), Vector2.new(engine_client.screen_center.x + 42, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x + 42, engine_client.screen_center.y + 9))
                Render.PolyFilled(Color.new(0, 0, 0, 0.3), Vector2.new(engine_client.screen_center.x + 40, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x + 38 , engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x + 38, engine_client.screen_center.y + 9), Vector2.new(engine_client.screen_center.x + 40, engine_client.screen_center.y + 9))
            end
            
            if references.yaw_base:Get() == 2 then
            
                Render.PolyFilled(manual_color, Vector2.new(engine_client.screen_center.x + 57, engine_client.screen_center.y), Vector2.new(engine_client.screen_center.x + 42, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x + 42, engine_client.screen_center.y + 9))
            elseif not references.yaw_base:Get() == 2 then
            
                Render.PolyFilled(Color.new(0, 0, 0, 0.3), Vector2.new(engine_client.screen_center.x + 57, engine_client.screen_center.y), Vector2.new(engine_client.screen_center.x + 42, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x + 42, engine_client.screen_center.y + 9))
            end
            
            if references.yaw_base:Get() == 3 then
            
                Render.PolyFilled(manual_color, Vector2.new(engine_client.screen_center.x - 57, engine_client.screen_center.y), Vector2.new(engine_client.screen_center.x - 42, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x - 42, engine_client.screen_center.y + 9))
            elseif not references.yaw_base:Get() == 3 then
            
                Render.PolyFilled(Color.new(0, 0, 0, 0.3), Vector2.new(engine_client.screen_center.x - 57, engine_client.screen_center.y), Vector2.new(engine_client.screen_center.x - 42, engine_client.screen_center.y - 9), Vector2.new(engine_client.screen_center.x - 42, engine_client.screen_center.y + 9))
            end
        end
    end

-- @end_region = Arrows Indicator
	

-- @region = Snaplines

    local snaplines = {}

    Tab["Visuals"].snaplines_bool = {
        var = Menu.SwitchColor("Visuals", "Visuals", "Snaplines", false, Color.new(1, 1, 1, 1), "ON/OFF Switch"), 
        color = false
    }

    snaplines.draw = function()

        if not Tab["Visuals"].snaplines_bool.var:Get() or not visuals_bool:Get() then
            return
        end

        local localplayer = isvalidlp()

        if localplayer == nil then 
            return 
        end

        local color = Tab["Visuals"].snaplines_bool.var:GetColor()
        
        local players = EntityList.GetPlayers()

        for _, player_ptr in ipairs(players) do

            if player_ptr == local_index or player_ptr:IsTeamMate() then 
                goto skip 
            end

            local position = Render.WorldToScreen(player_ptr:GetProp("m_vecOrigin"))
            Render.Line(position, Vector2.new(engine_client.screen_size.x / 2, engine_client.screen_size.y), color)

            ::skip::
        end
    end

-- @end_region = Snaplines


-- @region = Custom Scope Line

    local scope_line = {menu = {}}

    Tab["Visuals"].scopeline_bool = {var = Menu.Switch("Visuals", "Visuals", "Custom Scope", false, "This will give you more options to customise your scope."), color = false}
    Tab["Visuals"].scopeline_length = {var = Menu.SliderInt("Visuals", "Visuals", "Custom Scope Size", 60, 0, 1000), color = false}
    Tab["Visuals"].scopeline_offset = {var = Menu.SliderInt("Visuals", "Visuals", "Custom Scope Gap", 10, 0, 500), color = false}
    Tab["Visuals"].scopeline_color1 = {var = Menu.ColorEdit("Visuals", "Visuals", "Scope Inside Color", Color.RGBA(255, 255, 255)), color = true}
    Tab["Visuals"].scopeline_color2 = {var = Menu.ColorEdit("Visuals", "Visuals", "Scope Outside Color", Color.RGBA(255, 255, 255, 0)), color = true}

    scope_line.var = Menu.FindVar("Visuals", "View", "Camera", "Remove Scope")
    scope_line.ref = scope_line.var:Get()

    scope_line.anim_num = 0

    scope_line.on_draw = function()

        if not visuals_bool:Get() or not Tab["Visuals"].scopeline_bool.var:Get() then
            return
        end

        local localplayer = isvalidlp()

        if localplayer == nil then 
            return 
        end

        scope_line.var:SetInt(2)

        if localplayer:IsAlive() and localplayer:GetProp("m_bIsScoped") then 
            scope_line.anim_num = math_lerp(scope_line.anim_num, 1, 12 * GlobalVars.frametime)
        else
            scope_line.anim_num = math_lerp(scope_line.anim_num, 0, 12 * GlobalVars.frametime)
        end

        scope_line.offset = Tab["Visuals"].scopeline_offset.var:Get() * scope_line.anim_num
        scope_line.length = Tab["Visuals"].scopeline_length.var:Get() * scope_line.anim_num
        scope_line.col_1 = Tab["Visuals"].scopeline_color1.var:Get()
        scope_line.col_2 = Tab["Visuals"].scopeline_color2.var:Get()
        scope_line.width = 1

        scope_line.col_1.a = scope_line.col_1.a * scope_line.anim_num
        scope_line.col_2.a = scope_line.col_2.a * scope_line.anim_num

        --Left
        Render.GradientBoxFilled(Vector2.new(engine_client.screen_center.x - scope_line.offset, engine_client.screen_center.y), Vector2.new(engine_client.screen_center.x - scope_line.offset - scope_line.length, engine_client.screen_center.y + scope_line.width), scope_line.col_1, scope_line.col_2, scope_line.col_1, scope_line.col_2)

        --Right
        Render.GradientBoxFilled(Vector2.new(engine_client.screen_center.x + scope_line.offset, engine_client.screen_center.y), Vector2.new(engine_client.screen_center.x + scope_line.offset + scope_line.length, engine_client.screen_center.y + scope_line.width), scope_line.col_1, scope_line.col_2, scope_line.col_1, scope_line.col_2)

        --Up
        Render.GradientBoxFilled(Vector2.new(engine_client.screen_center.x, engine_client.screen_center.y + scope_line.offset), Vector2.new(engine_client.screen_center.x + scope_line.width, engine_client.screen_center.y + scope_line.offset + scope_line.length), scope_line.col_1, scope_line.col_1, scope_line.col_2, scope_line.col_2)

        --Down
        Render.GradientBoxFilled(Vector2.new(engine_client.screen_center.x, engine_client.screen_center.y - scope_line.offset), Vector2.new(engine_client.screen_center.x + scope_line.width, engine_client.screen_center.y - scope_line.offset - scope_line.length), scope_line.col_1, scope_line.col_1, scope_line.col_2, scope_line.col_2)
    end

    scope_line.on_destroy = function()
        scope_line.var:SetInt(scope_line.ref)
    end

-- @end_region = Custom Scope Line


-- @region = Damage Marker

Tab["Visuals"].damagemarker_bool = {
    var = Menu.Switch('Visuals', 'Visuals', 'Damage Marker', false, "This will render damage dealt to enemy."), 
    color = false
}
 
local damagemarkerlog = {}
 
damagemarkerlog.on_draw = function()

    if not Tab["Visuals"].damagemarker_bool.var:Get() or not visuals_bool:Get() then
        return
    end

    local localplayer = isvalidlp()

    if localplayer == nil then 
        return 
    end

    for i, marker in ipairs(damagemarkerlog) do

        marker.position.z = marker.position.z + 50*GlobalVars.frametime
        local position = Render.WorldToScreen(marker.position)
        marker.size = marker.size - GlobalVars.frametime*55

        Render.Text('-' .. marker.damage, Vector2.new(position.x+1,position.y+1), Color.new(0.1,0.1,0.1,1), math.floor(math.min(marker.size,12)),font.verdana12,false,true)
        Render.Text('-' .. marker.damage, Vector2.new(position.x,position.y), marker.enemylethal and Color.RGBA(155,200,20,255) or Color.RGBA(255,255,255,255), math.floor(math.min(marker.size,12)),font.verdana12,false,true)
        
        if marker.time + 3 < GlobalVars.realtime or marker.size < 0 then 
        table.remove(damagemarkerlog,i) 
        end
    end
end

damagemarkerlog.on_event = function(event)

    if not Tab["Visuals"].damagemarker_bool.var:Get() or not visuals_bool:Get() then
        return
    end

    if event:GetName() ~= "player_hurt" then 
        return 
    end

    local localplayer = isvalidlp()

    if localplayer == nil then 
        return 
    end

    victim = EntityList.GetPlayerForUserID(event:GetInt("userid"))
    if victim == nil then
		return
	end

    attacker = EntityList.GetPlayerForUserID(event:GetInt("attacker"))
    hitgroup = event:GetInt("hitgroup")
    dealtdmg = event:GetInt("dmg_health")
    enemyhealth = event:GetInt("health")
    hitgrouppos = victim:GetHitboxCenter(hitgroup)

    if attacker == localplayer:GetPlayer() then
        table.insert(damagemarkerlog, {size = 200, position = hitgrouppos, damage = dealtdmg, enemylethal = (enemyhealth < 1), time = GlobalVars.realtime})
    end
end

-- @end_region = Damage Marker


-- @region = Velocity Warning

Tab["Visuals"].velocitywarn_bool = {
    var = Menu.Switch("Visuals", "Visuals", "Velocity Warning", false), 
    color = false
}

local velocitywarning = {}
velocitywarning.anim_width = 0

velocitywarning.on_draw = function()

	if not Tab["Visuals"].velocitywarn_bool.var:Get() or not visuals_bool:Get() then 
        return
    end

    local localplayer = isvalidlp()

    if localplayer == nil then 
        return 
    end

    local modifier_vel = 0

    if Cheat.IsMenuVisible() then
        modifier_vel = 0.5
    else
        modifier_vel = localplayer:GetProp('m_flVelocityModifier') + 0.01
    end

    if modifier_vel == 1.01 then 
        return 
    end

    local alpha_vel = math.abs(GlobalVars.curtime*4 % 2 - 1)*255
    local text_vel = string.format('VELOCITY: %.0f%%', math.floor(modifier_vel*100))
    local text_width_vel = 95

    velocitywarning.anim_width = math_lerp(velocitywarning.anim_width, math.floor((text_width_vel - 2) * modifier_vel), GlobalVars.frametime * 8)

    local x_vel = engine_client.screen_size.x/2 - text_width_vel/2
    local y_vel = engine_client.screen_size.y/2 - 350

    Render.PolyFilled(Color.RGBA(16, 16, 16, 255), Vector2.new(x_vel - 14, y_vel - 16), Vector2.new(x_vel + 6 , y_vel + 14), Vector2.new(x_vel - 34, y_vel + 14))
    Render.PolyFilled(Color.new((124*2 - 124 * modifier_vel)/255, (195 * modifier_vel)/255, 13/255, alpha_vel/255), Vector2.new(x_vel - 14, y_vel - 14), Vector2.new(x_vel + 4 , y_vel + 13), Vector2.new(x_vel - 32, y_vel + 13))
    
    Render.Text('!', Vector2.new(x_vel - 18, y_vel - 12), Color.RGBA(16, 16, 16, 255), 25, font.verdana25)
    Render.Text(text_vel, Vector2.new(x_vel + 22, y_vel - 14), Color.RGBA(0, 0, 0, 255), 14, font.tahoma14bd)
    Render.Text(text_vel, Vector2.new(x_vel + 21, y_vel - 15), Color.RGBA(255, 255, 255, 255), 14, font.tahoma14bd)

    Render.BoxFilled(Vector2.new(x_vel + 21, y_vel + 2), Vector2.new(text_width_vel + engine_client.screen_size.x/2 - 26, y_vel + 14), Color.RGBA(16, 16, 16, 180))
    Render.BoxFilled(Vector2.new(x_vel + velocitywarning.anim_width + 23, y_vel + 3), Vector2.new(engine_client.screen_size.x/2 - 26, y_vel + 13), Color.new((124*2 - 124 * modifier_vel)/255, (195 * modifier_vel)/255, 13/255, 1))
end

-- @end_region = Velocity Warning


-- @region = Disable Third Person Animation

    local thirdperson_anim = {}

    Tab["Visuals"].thirdpersonanim_bool = {
        var = Menu.Switch("Visuals", "Visuals", "Disable 3rd Person Animation", false, "This will disable third person animation to change between the states faster."), 
        color = false
    }

    thirdperson_anim.toggle = function()
        if visuals_bool:Get() and Tab["Visuals"].thirdpersonanim_bool.var:Get() then
            Cheat.SetThirdPersonAnim(false)
        else
            Cheat.SetThirdPersonAnim(true)
        end
    end

    Tab["Visuals"].thirdpersonanim_bool.var:RegisterCallback(thirdperson_anim.toggle)
    Tab["Visuals"].visuals_bool.var:RegisterCallback(thirdperson_anim.toggle)
    thirdperson_anim.toggle()

-- @end_region = Disable Third Person Animation


-- @region = Viewmodel On Scope

    local viewmodel_scope = {}

    Tab["Visuals"].viewmodelscope_bool = {
        var = Menu.Switch("Visuals", "Visuals", "Viewmodel On Scope", false, "This will render your viewmodel when scoped."), 
        color = false
    }

    viewmodel_scope.fov_cs_debug = CVar.FindVar("fov_cs_debug")

    viewmodel_scope.toggle = function()

        local localplayer = isvalidlp()

        if localplayer == nil then 
            return 
        end

        if Tab["Visuals"].viewmodelscope_bool.var:Get() and visuals_bool:Get() and localplayer:GetProp("m_bIsScoped") then
            viewmodel_scope.fov_cs_debug:SetInt(90)
        else
            viewmodel_scope.fov_cs_debug:SetInt(0)
        end
    end

    viewmodel_scope.restore = function()
        viewmodel_scope.fov_cs_debug:SetInt(0)
    end

-- @end_region = Viewmodel On Scope


-- @region = Skeet Autopeek

    local skeet_autopeek = {}

    Tab["Misc"].skeetap_bool = {
        var = Menu.Switch("Misc", "Misc", "Skeet AutoPeek", false), 
        color = false
    }

    skeet_autopeek.setmovement = function(xz,yz,cmd)

        local localplayer = isvalidlp()

        if localplayer == nil then 
            return 
        end

        local current_pos = localplayer:GetProp("m_vecOrigin")

        local yaw = EngineClient:GetViewAngles().yaw

        local vector_forward = {
            x = current_pos.x - xz,
            y = current_pos.y - yz,
        }    

        local velocity = {
            x = -(vector_forward.x * math.cos(yaw / 180 * math.pi) + vector_forward.y * math.sin(yaw / 180 * math.pi)),
            y = vector_forward.y * math.cos(yaw / 180 * math.pi) - vector_forward.x * math.sin(yaw / 180 * math.pi),
        }

        cmd.forwardmove = velocity.x * 15
        cmd.sidemove = velocity.y * 15
    end

    skeet_autopeek.on_prediction = function(cmd)

        if not Tab["Misc"].skeetap_bool.var:Get() or not misc_bool:Get() then
            return
        end
    
        local localplayer = isvalidlp()

        if localplayer == nil then 
            return 
        end

        local forw = bit.band(cmd.buttons, 8) == 8
        local back = bit.band(cmd.buttons, 16) == 16
        local righ = bit.band(cmd.buttons, 512) == 512
        local left = bit.band(cmd.buttons, 1024) == 1024
    
        local originalpos = localplayer:GetProp("m_vecOrigin")
        if references.isAP:Get() then
            if forw == false and back == false and left == false and righ == false and curpos.x ~= originalpos.x and curpos.y ~= originalpos.y then
                skeet_autopeek.setmovement(curpos.x,curpos.y, cmd)
            end
        else
            curpos = localplayer:GetProp("m_vecOrigin")
        end
    end

-- @end_region = Skeet Autopeek


-- @region = Custom Hitsound

    local hitsound = {}

    Tab["Misc"].hitsound_bool = {
        var = Menu.Switch("Misc", "Misc", "Custom Hitsound", false), 
        color = false
    }
    Tab["Misc"].hitsound_combo = {
        var = Menu.Combo("Misc", "Misc", "Hitsound:", {"Skeet", "Glass","Old SSG-08","Old AWP"}, 0), 
        color = false
    }
    Tab["Misc"].hitsound_volume = {
        var = Menu.SliderInt("Misc", "Misc", "Hitsound Volume", 50, 1, 100), 
        color = false
    }

    hitsound.on_event = function(event)

        if not Tab["Misc"].hitsound_bool.var:Get() or not misc_bool:Get() then
            return
        end

        if event:GetName() == "player_hurt" then

            if event:GetInt("attacker", 0) ~= EntityList.GetLocalPlayer():GetPlayerInfo().userId then
                return
            end

            local hitsound_volume = (Tab["Misc"].hitsound_volume.var:Get() / 100)

            Menu.FindVar("Visuals","World", "Hit", "Hit Sound"):SetBool(false)

            if Tab["Misc"].hitsound_combo.var:Get() == 0 then
                EngineClient.ExecuteClientCmd(string.format("playvol buttons/arena_switch_press_02 %s", hitsound_volume))
            elseif Tab["Misc"].hitsound_combo.var:Get() == 1 then
                EngineClient.ExecuteClientCmd(string.format("playvol valency.lua/glass.wav %s", hitsound_volume))
            elseif Tab["Misc"].hitsound_combo.var:Get() == 2 then
                EngineClient.ExecuteClientCmd(string.format("playvol weapons/ssg08/ssg08-1 %s", hitsound_volume))
            elseif Tab["Misc"].hitsound_combo.var:Get() == 3 then
                EngineClient.ExecuteClientCmd(string.format("playvol weapons/awp/awp1 %s", hitsound_volume))
            end
        end
    end

-- @end_region = Custom Hitsound


-- @region = ANIM BREAKER 

    Tab["Global"].animbreaker_mcombo = {
        var = Menu.MultiCombo("Global", "Global", "Anim. Breaker", {"Leg Fucker", "Static Legs In Air","Zero Pitch On Land"}, 0), 
        color = false
    }

-- @end_region = ANIM BREAKER
	

-- @region = DISCORD SERVER 

    local DiscordServer = Menu.Button("Info","Info/Issues","Discord Server", "Click to enter our discord server!", function()
        Panorama.Open().SteamOverlayAPI.OpenExternalBrowserURL("https://discord.gg/He39nZg3mE")
    end)

-- @end_region = DISCORD SERVER


-- @region = CONFIG SYSTEM

    local configs = {}

    configs.validation_key = "2050octa1992010yelun45ou312nh10p"

    configs.export = Menu.Button("Config", "Config", "Export Config To Clipboard", "Click here to export the config.", function()
        local protected = function()

            local menu_items = {}
            for k, v in pairs(Tab) do
                local table_tab = {}

                for j, l in pairs(v) do
                    local table_element = {}
                    table_element.value = l.var:Get()

                    if type(table_element.value) == "userdata" then
                        table_element.color = convertcolor_tostr(table_element.value)
                        table_element.value = nil
                    else
                        table_element.color = l.color and convertcolor_tostr(l.var:GetColor()) or nil
                    end

                    if table_element.color == nil and table_element.value == nil then
                        goto skip
                    end
        
                    table_tab[j] = table_element
        
                    ::skip::
                end

                menu_items[k] = table_tab
            end

            menu_items["Username"] = {value = player_name.cheat}
            menu_items[configs.validation_key] = true

            local jsonraw = JSON.stringify(menu_items)
            local cfgencoded = (M.encode(jsonraw))
            setclipboardtext("valency_" .. cfgencoded)

            logs[#logs+1] = {
                {
                    {
                        text = "[VALENCY] ",
                        color = Color.RGBA(210, 255, 0, 255)
                    },
                    {
                        text = "Successfully ",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = "Exported ",
                        color = Color.RGBA(210, 255, 0, 255)
                    },
                    {
                        text = "Config",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = "!",
                        color = Color.RGBA(210, 255, 0, 255)
                    },
                }, GlobalVars.realtime + 2, 0,
            }
        end

        local status, message = pcall(protected)

        if not status then
            logs[#logs+1] = {
                {
                    {
                        text = "[VALENCY] ",
                        color = Color.RGBA(255, 0, 0, 255)
                    },
                    {
                        text = "Failed ",
                        color = Color.RGBA(255, 0, 0, 255)
                    },
                    {
                        text = "to ",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = "Export ",
                        color = Color.RGBA(255, 0, 0, 255)
                    },
                    {
                        text = "Config",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = "!",
                        color = Color.RGBA(255, 0, 0, 255)
                    },
                }, GlobalVars.realtime + 2, 0,
            }
            print(string.format("Failed to export config:\nReason: %s\nJson: %s", message, jsonraw))
            return
        end
    end)



    configs.load = Menu.Button("Config", "Config", "Import Config From Clipboard", "Click here to import the config.", function()
        configs.load(getclipboardtext())
    end)

    configs.defaultbutton = Menu.Button("Config", "Config", "Load Default Config", "",function()
        defaultconfiglink = "https://raw.githubusercontent.com/TiagoSuper3/neverlosenokiascript/main/aa.txt"
        Http.GetAsync(defaultconfiglink, function(url_content)
            local clipboardtextbefore = getclipboardtext()
            configs.load(url_content)
            setclipboardtext(clipboardtextbefore)
        end)
    end)


    configs.load = function(text)

        local protected = function()
            local clipboard = text == nil and getclipboardtext() or text

            if clipboard:match("valency_") == nil then
                error("Wrong Script Config or Its Missing Entry Key.")
                return
            end
            clipboard = (clipboard:gsub("valency_" , ""))

            local jsonparse = M.decode(clipboard)
            if jsonparse:match(configs.validation_key) == nil then
                error("Didn't find key for validation!")
                return
            end

            jsonparse = json.decode(jsonparse)

            local phasesparse = 0

            for k, v in pairs(jsonparse) do

                if k == configs.validation_key then
                    goto skip
                end

                for j, l in pairs(v) do

                    if k == "Username" then
                        parse_username = l
                        goto skip
                    end

                    if j:match("phases_number") ~= nil then
                        phasesparse = l.value
                    end

                    if l.color ~= nil then
                        Tab[k][j].var:SetColor(Color.RGBA(l.color.r, l.color.g, l.color.b, l.color.a))
                    end

                    if l.value ~= nil then
                        Tab[k][j].var:Set(l.value)
                    end
                end

                ::skip::
            end
        
            if phasesparse > #antibruteforce.sliders_count then
                while phasesparse > #antibruteforce.sliders_count do
                    antibruteforce.add_phase()
                end
            else
                while phasesparse < #antibruteforce.sliders_count do
                    antibruteforce.remove_phase()
                end
            end

            for i = 1, phasesparse do
                Tab["Anti Bruteforce"]["phase_" .. i].var:Set(jsonparse["Anti Bruteforce"]["phase_" .. i].value)
            end

            update_global_visibility()

            logs[#logs+1] = {
                {
                    {
                        text = "[VALENCY] ",
                        color = Color.RGBA(199, 255, 0, 255)
                    },
                    {
                        text = "Successfully ",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = "Loaded ",
                        color = Color.RGBA(199, 255, 0, 255)
                    },
                    {
                        text = ""..parse_username.." ",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = "Config",
                        color = Color.RGBA(199, 255, 0, 255)
                    },
                    {
                        text = "!",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                }, GlobalVars.realtime + 2, 0,
            }
        end

        local status, message = pcall(protected)
        if not status then
            logs[#logs+1] = {
                {
                    {
                        text = "[VALENCY] ",
                        color = Color.RGBA(255, 0, 0, 255)
                    },
                    {
                        text = "Failed ",
                        color = Color.RGBA(255, 0, 0, 255)
                    },
                    {
                        text = "to ",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = "Load ",
                        color = Color.RGBA(255, 0, 0, 255)
                    },
                    {
                        text = "Config",
                        color = Color.RGBA(255, 255, 255, 255)
                    },
                    {
                        text = "!",
                        color = Color.RGBA(255, 0, 0, 255)
                    },
                }, GlobalVars.realtime + 2, 0,
            }
            print("Failed to load config:", message)
            return
        end
    end

-- @end_region = CONFIG SYSTEM


-----------------------------SET VISIBLE--------------------------------------

    local hud = {state = {}}

    hud.visibility_global = function()
        Tab["Global"].ax_bool.var:SetVisible(global_bool:Get())
        Tab["Global"].dtspeed_bool.var:SetVisible(global_bool:Get())
        Tab["Global"].dtspeed_slider.var:SetVisible(global_bool:Get() and Tab["Global"].dtspeed_bool.var:Get())
        Tab["Global"].hcair_bool.var:SetVisible(global_bool:Get())
        Tab["Global"].hcair_slider.var:SetVisible(global_bool:Get() and Tab["Global"].hcair_bool.var:Get())
        Tab["Global"].hcnoscope_bool.var:SetVisible(global_bool:Get())
        Tab["Global"].hcnoscope_slider.var:SetVisible(global_bool:Get() and Tab["Global"].hcnoscope_bool.var:Get())
        Tab["Global"].forcebaimonlethal_bool.var:SetVisible(global_bool:Get())
        Tab["Global"].dormantaimbot_bool.var:SetVisible(global_bool:Get())
        Tab["Global"].dormantaimbot_slider.var:SetVisible(global_bool:Get() and Tab["Global"].dormantaimbot_bool.var:Get())
        Tab["Global"].animbreaker_mcombo.var:SetVisible(global_bool:Get())
    end

    hud.visibility_aa = function()

        local isAA = aa[0].antiaims:Get()
        vis(aa[0].manual, true)
        vis(aa[0].antiaim, aa[0].antiaims:Get())
        currentid = aa[0].antiaim:Get() + 1


        Tab["Anti Aim"].airtp_mcombo.var:SetVisible(Tab["Anti Aim"].airtp_bool.var:Get())
        Tab["Anti Aim"].antibackstab_mcombo.var:SetVisible(Tab["Anti Aim"].antibackstab_bool.var:Get())

        for i = 1, 8 do
            vis(aa[i].custom_enable, isAA  and currentid == i)
            vis(aa[i].custom_yaw_base, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_pitch, isAA and  aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_yaw_add_left, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_yaw_add_right, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_yaw_modifier, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_modifier_type, isAA  and aa[i].custom_yaw_modifier:Get() ~= 0 and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_modifier_jitter, aa[i].custom_yaw_modifier:Get() ~= 0 and aa[i].custom_modifier_type:Get() ~= 0 and isAA and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_modifier_degree, aa[i].custom_yaw_modifier:Get() ~= 0 and isAA and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_left_limit, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_right_limit, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_left_limit2, isAA  and aa[i].custom_enable:Get() and currentid == i and aa[i].custom_fake_type:Get()==3)
            vis(aa[i].custom_right_limit2, isAA and aa[i].custom_enable:Get() and currentid == i and aa[i].custom_fake_type:Get()==3)
            vis(aa[i].custom_options, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_lby, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_fs, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_onshot, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_fake_type, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_fake_type_custom, isAA  and aa[i].custom_enable:Get() and aa[i].custom_fake_type:Get()==3 and currentid == i)
            vis(aa[i].rae, isAA and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].ref, isAA and aa[i].rae:Get() and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].warningroll, isAA  and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].warningex, isAA and aa[i].rae:Get() and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_roll_left, isAA and aa[i].rae:Get() and aa[i].ref:Get() == 3 and aa[i].custom_enable:Get() and currentid == i)
            vis(aa[i].custom_roll_right, isAA and aa[i].rae:Get() and aa[i].ref:Get() == 3 and aa[i].custom_enable:Get() and currentid == i)
        end

        vis(aa[1].custom_enable, false)

        vis(aa[2].rae, false)
        vis(aa[2].ref, false)
        vis(aa[2].warningroll, false)
        vis(aa[2].warningex, false)
        vis(aa[2].custom_roll_left, false)
        vis(aa[2].custom_roll_right, false)

        vis(aa[9].custom_enable, false)
        vis(aa[9].custom_yaw_base, not isAA)
        vis(aa[9].custom_pitch, not isAA)
        vis(aa[9].custom_yaw_add_left, not isAA)
        vis(aa[9].custom_yaw_add_right, not isAA)
        vis(aa[9].custom_yaw_modifier, not isAA)
        vis(aa[9].custom_modifier_type, not isAA and aa[9].custom_yaw_modifier:Get() == 1 or aa[9].custom_yaw_modifier:Get() == 2)
        vis(aa[9].custom_modifier_jitter, not isAA and aa[9].custom_yaw_modifier:Get() ~= 0 and aa[9].custom_modifier_type:Get() ~= 0)
        vis(aa[9].custom_modifier_degree, not isAA and aa[9].custom_yaw_modifier:Get() ~= 0)
        vis(aa[9].custom_left_limit, not isAA)
        vis(aa[9].custom_right_limit, not isAA)
        vis(aa[9].custom_left_limit2, not isAA and aa[9].custom_fake_type:Get()==3)
        vis(aa[9].custom_right_limit2, not isAA and aa[9].custom_fake_type:Get()==3)
        vis(aa[9].custom_options, not isAA)
        vis(aa[9].custom_lby, not isAA)
        vis(aa[9].custom_fs, not isAA)
        vis(aa[9].custom_onshot, not isAA)
        vis(aa[9].custom_fake_type, not isAA)
        vis(aa[9].custom_fake_type_custom, not isAA and aa[9].custom_fake_type:Get()==3)
        vis(aa[9].rae, not isAA)
        vis(aa[9].ref, not isAA and aa[9].rae:Get())
        vis(aa[9].warningroll, not isAA)
        vis(aa[9].warningex, not isAA and aa[9].rae:Get())
        vis(aa[9].custom_roll_left, not isAA and aa[9].rae:Get() and aa[9].ref:Get() == 3)
        vis(aa[9].custom_roll_right, not isAA and aa[9].rae:Get() and aa[9].ref:Get() == 3)
    end

    hud.visibility_ab = function()
        Tab["Anti Bruteforce"].add_phase.var:SetVisible(antibruteforce_bool:Get())
        Tab["Anti Bruteforce"].remove_phase.var:SetVisible(antibruteforce_bool:Get())
        for i = 1, #antibruteforce.sliders_count do
            Tab["Anti Bruteforce"]["phase_" .. i].var:SetVisible(antibruteforce_bool:Get())
        end
    end

    hud.visibility_visuals = function()
        Tab["Visuals"].scopeline_offset.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].scopeline_bool.var:Get())
        Tab["Visuals"].scopeline_length.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].scopeline_bool.var:Get())
        Tab["Visuals"].scopeline_color1.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].scopeline_bool.var:Get())
        Tab["Visuals"].scopeline_color2.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].scopeline_bool.var:Get())
        Tab["Visuals"].arows_combo.var:SetVisible(visuals_bool:Get())
        Tab["Visuals"].arrows_mainCol.var:SetVisible(visuals_bool:Get() and (Tab["Visuals"].arows_combo.var:Get() == 1 or Tab["Visuals"].arows_combo.var:Get() == 2))
        Tab["Visuals"].arrows_manuaCol.var:SetVisible(visuals_bool:Get() and (Tab["Visuals"].arows_combo.var:Get() == 2))
        Tab["Visuals"].thirdpersonanim_bool.var:SetVisible(visuals_bool:Get())
        Tab["Visuals"].viewmodelscope_bool.var:SetVisible(visuals_bool:Get())
        Tab["Visuals"].snaplines_bool.var:SetVisible(visuals_bool:Get())
        Tab["Visuals"].velocitywarn_bool.var:SetVisible(visuals_bool:Get())
        Tab["Visuals"].widgets_mcombo.var:SetVisible(visuals_bool:Get())
        Tab["Visuals"].indic_bool.var:SetVisible(visuals_bool:Get())
        Tab["Visuals"].indic_mcombo.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].indic_bool.var:Get())
        Tab["Visuals"].solus_username_combo.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].widgets_mcombo.var:Get(1))
        Tab["Visuals"].solus_cheatname_combo.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].widgets_mcombo.var:Get(1))       
        Tab["Visuals"].solus_style_combo.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].widgets_mcombo.var:Get() ~= 0)
        Tab["Visuals"].solus_customusername.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].widgets_mcombo.var:Get(1) and Tab["Visuals"].solus_username_combo.var:Get() == 2)
        Tab["Visuals"].solus_color.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].widgets_mcombo.var:Get() ~= 0)
        Tab["Visuals"].scopeline_bool.var:SetVisible(visuals_bool:Get())
        Tab["Visuals"].damagemarker_bool.var:SetVisible(visuals_bool:Get())
        Tab["Visuals"].indic_logoCol.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].indic_bool.var:Get())
        Tab["Visuals"].indic_desyncCol.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].indic_bool.var:Get())
        Tab["Visuals"].indic_lineCol.var:SetVisible(visuals_bool:Get() and Tab["Visuals"].indic_bool.var:Get() and Tab["Visuals"].indic_mcombo.var:Get(1))
    end

    hud.visibility_misc = function()
        Tab["Misc"].clantag_bool.var:SetVisible(misc_bool:Get())
        Tab["Misc"].trashtalk_bool.var:SetVisible(misc_bool:Get())
        Tab["Misc"].consoleCol_bool.var:SetVisible(misc_bool:Get())
        Tab["Misc"].hitlogs_bool.var:SetVisible(misc_bool:Get())
        Tab["Misc"].hitlogs_consColor.var:SetVisible(misc_bool:Get() and Tab["Misc"].hitlogs_bool.var:Get() and Tab["Misc"].hitlogs_mcombo.var:Get(2))
        Tab["Misc"].hitlogs_spread.var:SetVisible(misc_bool:Get() and Tab["Misc"].hitlogs_bool.var:Get() and Tab["Misc"].hitlogs_mcombo.var:Get(2))
        Tab["Misc"].hitlogs_resolv.var:SetVisible(misc_bool:Get() and Tab["Misc"].hitlogs_bool.var:Get() and Tab["Misc"].hitlogs_mcombo.var:Get(2))
        Tab["Misc"].hitlogs_prederr.var:SetVisible(misc_bool:Get() and Tab["Misc"].hitlogs_bool.var:Get() and Tab["Misc"].hitlogs_mcombo.var:Get(2))
        Tab["Misc"].hitlogs_mcombo.var:SetVisible(misc_bool:Get() and Tab["Misc"].hitlogs_bool.var:Get())
        Tab["Misc"].hitlogs_notColor.var:SetVisible(misc_bool:Get() and Tab["Misc"].hitlogs_bool.var:Get() and Tab["Misc"].hitlogs_mcombo.var:Get(1))
        Tab["Misc"].hitsound_bool.var:SetVisible(misc_bool:Get())
        Tab["Misc"].hitsound_combo.var:SetVisible(misc_bool:Get() and Tab["Misc"].hitsound_bool.var:Get())
        Tab["Misc"].hitsound_volume.var:SetVisible(misc_bool:Get() and Tab["Misc"].hitsound_bool.var:Get())
        Tab["Misc"].skeetap_bool.var:SetVisible(misc_bool:Get())
    end

    update_global_visibility = function()
        hud.visibility_global()
        hud.visibility_aa()
        hud.visibility_ab()
        hud.visibility_visuals()
        hud.visibility_misc()
        hud.blockmenucombos()
    end

    --block menu combos

        hud.windows = Menu.FindVar("Miscellaneous", "Main", "Other", "Windows")

        hud.get_states = function()
            for i = 1, 3 do
                hud.state[i] = Menu.FindVar("Miscellaneous", "Main", "Other", "Windows"):Get(i)
            end
        end
        hud.get_states()

        hud.blockmenucombos = function()

            if Tab["Visuals"].widgets_mcombo.var:Get(1) and visuals_bool:Get() then   
                hud.windows:Set(3,false)
            else
                hud.windows:Set(3,hud.state[3])
            end

            if Tab["Visuals"].widgets_mcombo.var:Get(2) and visuals_bool:Get() then   
                hud.windows:Set(1,false)
            else
                hud.windows:Set(1,hud.state[1])
            end

            if Tab["Visuals"].widgets_mcombo.var:Get(3) and visuals_bool:Get() then   
                hud.windows:Set(2,false)
            else
                hud.windows:Set(2,hud.state[2])
            end

        end

        hud.destroy = function()
            for i = 1, 3 do
                hud.windows:Set(i,hud.state[i])
            end
        end

        for _, v in pairs(Tab["Global"]) do 
            v.var:RegisterCallback(hud.visibility_global) 
        end
        for _, v in pairs(Tab["Anti Aim"]) do 
            v.var:RegisterCallback(hud.visibility_aa) 
        end
        for _, v in pairs(Tab["Anti Bruteforce"]) do 
            v.var:RegisterCallback(hud.visibility_ab) 
        end
        for _, v in pairs(Tab["Visuals"]) do 
            v.var:RegisterCallback(hud.visibility_visuals) 
            v.var:RegisterCallback(hud.blockmenucombos)  
        end
        for _, v in pairs(Tab["Misc"]) do 
            v.var:RegisterCallback(hud.visibility_misc) 
        end

        update_global_visibility()

-------------------------------------------------------------------------------------------------





-- @region = Callbacks

local destroy = function()
    console.updateConsoleColor(1, 1, 1, 1)
    scope_line.on_destroy()
    clantag.clean()
    viewmodel_scope.restore()
    anti_defensive.destroy()
    floff_onhs.restore_fl()
    hud.destroy()
end

local events = function(event)

    if not boot_animation.anim_loaded then 
        return 
    end

    force_onshot.on_event(event)
    killsay.event(event)
    hitsound.on_event(event)
    damagemarkerlog.on_event(event)
    antibruteforce.on_event(event)
    printHitInfo(event)
end

local createmove = function()

    if not boot_animation.anim_loaded then 
        return 
    end

    auto_teleport.createmove()
end



local prediction = function(cmd)

    if not boot_animation.anim_loaded then 
        return 
    end

    hook_aa.apply_condition(cmd)
    skeet_autopeek.on_prediction(cmd)
    dormant_aimbot.prediction(cmd)
    hitchance.air()
    hitchance.noscope()
    doubletap_speed.prediction()
    anti_backstab.prediction()
    force_onshot.on_prediction()
    forcebaim_lethal.on_prediction()
end



local pre_prediction = function()

    if not boot_animation.anim_loaded then 
        return 
    end

    hook_aa.update_jitter()
end



local draw = function()

    if not boot_animation.anim_loaded then 
        boot_animation.startup()
        return 
    end

    hitmisslogs()
    scope_line.on_draw()
    console.color_draw()
    clantag.draw()
    indicatorarrows()
    snaplines.draw()
    damagemarkerlog.on_draw()
    antibruteforce.restart_time()

    solus.watermark()
    solus.keybinds()
    solus.spectators()

    velocitywarning.on_draw()
    indicators.draw()
    lualogo_menu.draw()
    viewmodel_scope.toggle()
end



local registered_shot = function(shot)

    if not boot_animation.anim_loaded then 
        return 
    end

    printMissInfo(shot)
end

Cheat.RegisterCallback("draw", draw)
Cheat.RegisterCallback("destroy", destroy)
Cheat.RegisterCallback("events", events)
Cheat.RegisterCallback("createmove", createmove)
Cheat.RegisterCallback("pre_prediction", pre_prediction)
Cheat.RegisterCallback("prediction", prediction)
Cheat.RegisterCallback("registered_shot", registered_shot)

-- @end_region = Callbacks

-- Finally this is where da pasta ends xD
 
